"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3464],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>u,MDXProvider:()=>d,mdx:()=>y,useMDXComponents:()=>c,withMDXComponents:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=a.createContext({}),m=function(e){return function(t){var n=c(t.components);return a.createElement(e,r({},t,{components:n}))}},c=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,h=m["".concat(i,".").concat(d)]||m[d]||p[d]||r;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},64465:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>i,contentTitle:()=>l,metadata:()=>s,toc:()=>u,default:()=>c});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i={id:"asynchronous-layout",title:"Asynchronous Layout"},l=void 0,s={unversionedId:"asynchronous-layout",id:"asynchronous-layout",isDocsHomePage:!1,title:"Asynchronous Layout",description:"Immutability and thread safety",source:"@site/../docs/asynchronous-layout.md",sourceDirName:".",slug:"/asynchronous-layout",permalink:"/docs/asynchronous-layout",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/asynchronous-layout.md",version:"current",frontMatter:{id:"asynchronous-layout",title:"Asynchronous Layout"}},u=[{value:"Immutability and thread safety",id:"immutability-and-thread-safety",children:[]},{value:"Sync and Async operations",id:"sync-and-async-operations",children:[]}],m={toc:u};function c(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.mdx)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("h2",{id:"immutability-and-thread-safety"},"Immutability and thread safety"),(0,r.mdx)("p",null,"Most issues with thread safety derive from concurrent reads and writes on mutable objects. This is how a classic example of this problem looks in Java:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'  public class SomeExampleClass {\n    private int mCounter;\n\n    public String getThisOrThat() {\n      if (mCounter > 10) {\n        return "this":\n      } else {\n        mCounter++;\n        return "that";\n      }\n    }\n  }\n\n')),(0,r.mdx)("p",null,"If multiple threads were to invoke ",(0,r.mdx)("inlineCode",{parentName:"p"},"getThisOrThat")," on a shared instance of ",(0,r.mdx)("inlineCode",{parentName:"p"},"SomeExampleClass")," that would be the most classic example of race condition. By the time the second thread entering the method tries to read ",(0,r.mdx)("inlineCode",{parentName:"p"},"mCounter"),", the first thread might be in the process of executing ",(0,r.mdx)("inlineCode",{parentName:"p"},"mCounter++")," and we wouldn't be able to determine what's the value that the second thread would actually read from ",(0,r.mdx)("inlineCode",{parentName:"p"},"mCounter"),".\nThe problem in general is that in this code there is a mutable state (",(0,r.mdx)("inlineCode",{parentName:"p"},"mCounter"),") and multiple threads trying to write and read it.\nRace conditions are the most common problem when writing applications that try to distribute work on multiple threads."),(0,r.mdx)("p",null,"This is exactly why traditionally, running UI code on multiple thread has always been extremely complex.\nAndroid views are stateful and mutable. A ",(0,r.mdx)("inlineCode",{parentName:"p"},"TextView")," for example, has to keep track of the current text that it's displaying and at the same time exposes a ",(0,r.mdx)("inlineCode",{parentName:"p"},"setText()")," method that allows the developer to mutate the text.\nThis means that if the Android UI framework decided to offload things like layout calculation on a secondary thread, it would have to solve the problem of a user calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"setText()")," from another thread and mutating the current text while\nthe layout computation is happening."),(0,r.mdx)("p",null,"Let's go back for a second to our sample code. We said that the main problem there was the mutable state ",(0,r.mdx)("inlineCode",{parentName:"p"},"mCounter")," accessed inside our ",(0,r.mdx)("inlineCode",{parentName:"p"},"getThisOrThat()")," method. Is there a way to write code that is functionally equivalent without having to rely on such mutable state?\nLet's try to imagine for a moment that no object can ever mutate its content after creation. If nothing can mutate, we can't ever have races between threads trying to mutate and read the same state.\nWe can rewrite our sample code to look like this:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java"},'\n  public static class Result {\n    public final int mCounter;\n    public final String mValue;\n\n    public Result(int counter, int value) {\n      mCounter = counter;\n      mValue = value;\n    }\n  }\n\n  public class SomeExampleClass {\n    public static Result getThisOrThat(int counterValue) {\n      if (counterValue > 10) {\n        return new Result(counterValue, "this"):\n      } else {\n        return new Result(counterValue + 1, "that");\n      }\n    }\n  }\n\n')),(0,r.mdx)("p",null,"Our method is now completely thread safe as it never modifies any internal state of ",(0,r.mdx)("inlineCode",{parentName:"p"},"SomeExampleClass"),". In this example ",(0,r.mdx)("inlineCode",{parentName:"p"},"getThisOrThat()")," is what's called a 'pure function' as its result only depends on the inputs and it doesn't have any side effect."),(0,r.mdx)("p",null,"In Litho we try to apply exactly the same concepts to layout computation. A ",(0,r.mdx)("inlineCode",{parentName:"p"},"Component")," is an immutable object that contains all the inputs for the layout function in form of ",(0,r.mdx)("inlineCode",{parentName:"p"},"@Prop")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"@State")," values. This also explains why we need ",(0,r.mdx)("inlineCode",{parentName:"p"},"@Prop")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"@State")," to be immutable. If they weren't, we would lose the property of having layout as a 'pure function'."),(0,r.mdx)("p",null,"Immutability in Java usually comes at the cost of having to do many more allocations. Even in our simple example we are now allocating a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Result")," object for every invocation of our function. Litho uses pooling and ",(0,r.mdx)("a",{parentName:"p",href:"codegen"},"code generation")," to minimize object allocations for you automatically."),(0,r.mdx)("h2",{id:"sync-and-async-operations"},"Sync and Async operations"),(0,r.mdx)("p",null,"Litho offers both synchronous and asynchronous APIs for layout computation. Both APIs are thread safe and can be invoked from any thread. The final layout will always represent the Component that was set last with calls to ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRootAsync()"),"."),(0,r.mdx)("p",null,"Synchronous layout calculation ensures that immediately after calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," on a ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/ComponentTree.html"},"ComponentTree"),", the result of the layout calculation is available to be mounted on a ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/LithoView.html"},"LithoView"),".\nThe main disadvantage of this is that the computation happens on the caller thread, therefore calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," from the main thread is not advisable. On the other hand there are situations in which you cannot wait for a background thread to compute a layout before showing something on screen, for example when the item you want to display is already in the viewport. In these cases calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," synchronously is the best route.\nHaving synchronous operations also makes it very easy to integrate Litho with pre-existing threading models. If your application already has a complex and structured thread design you might want to fit the layout calculation into it without relying on Litho's built-in threads."),(0,r.mdx)("p",null,"Asynchronous layout calculation will use Litho's Layout Thread to compute the Component layout. This means that the work gets enqueued immediately on a separate thread and the layout result will not be visible immediately on the calling thread. Asynchronous layout operations are used widely for example from the ",(0,r.mdx)("a",{parentName:"p",href:"recycler-component"},"RecyclerBinder"),"."))}c.isMDXComponent=!0}}]);