"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[660],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>l,mdx:()=>u,useMDXComponents:()=>m,withMDXComponents:()=>p});var o=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=o.createContext({}),p=function(e){return function(n){var t=m(n.components);return o.createElement(e,a({},n,{components:t}))}},m=function(e){var n=o.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=m(e.components);return o.createElement(d.Provider,{value:n},e.children)},f={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=m(t),l=i,h=p["".concat(r,".").concat(l)]||p[l]||f[l]||a;return t?o.createElement(h,s(s({ref:n},d),{},{components:t})):o.createElement(h,s({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<a;d++)r[d]=t[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},81347:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>r,contentTitle:()=>s,metadata:()=>c,toc:()=>d,default:()=>m});var o=t(87462),i=t(63366),a=(t(67294),t(3905)),r={id:"diff-sections",title:"Advanced: Writing your own DiffSection"},s=void 0,c={unversionedId:"sections/diff-sections",id:"sections/diff-sections",isDocsHomePage:!1,title:"Advanced: Writing your own DiffSection",description:"In this document we will describe how to build your own DiffSection. The Sections API already provides two implementations that cover most frequent use cases in SingleComponentSection and DataDiffSection. You should write your own DiffSection if the given implementations do not suffice for your use case, as the complexity and chances of introducing subtle errors are both high.",source:"@site/../docs/sections/diff-sections.md",sourceDirName:"sections",slug:"/sections/diff-sections",permalink:"/docs/sections/diff-sections",editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/sections/diff-sections.md",version:"current",frontMatter:{id:"diff-sections",title:"Advanced: Writing your own DiffSection"},sidebar:"mainSidebar",previous:{title:"Advanced: Mixing with Android Views",permalink:"/docs/sections/view-support"},next:{title:"Internal \ud83c\udfd7: Sections implementation architecture",permalink:"/docs/sections/architecture"}},d=[{value:"DiffSectionSpec",id:"diffsectionspec",children:[]},{value:"Making changes to the list with ChangeSet",id:"making-changes-to-the-list-with-changeset",children:[]}],p={toc:d};function m(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,a.mdx)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"In this document we will describe how to build your own ",(0,a.mdx)("inlineCode",{parentName:"p"},"DiffSection"),". The Sections API already provides two implementations that cover most frequent use cases in ",(0,a.mdx)("inlineCode",{parentName:"p"},"SingleComponentSection")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"DataDiffSection"),". ",(0,a.mdx)("strong",{parentName:"p"},"You should write your own ",(0,a.mdx)("inlineCode",{parentName:"strong"},"DiffSection")," if the given implementations do not suffice for your use case"),", as the complexity and chances of introducing subtle errors are both high."),(0,a.mdx)("h2",{id:"diffsectionspec"},"DiffSectionSpec"),(0,a.mdx)("p",null,"A ",(0,a.mdx)("em",{parentName:"p"},"diff section spec")," defines a section that explicitly outputs insert, update, and remove changes on the section hierarchy."),(0,a.mdx)("p",null,"Diff section specs explicitly manage insertions, removals, and updates that a section performs whenever its states and props change.  You will find Diff Sections at the leaves of every section tree as they are the sections that actually specify the changes to be made to a list."),(0,a.mdx)("p",null,"One example where you might want a custom diff section is if you receive the data you want to display in the form of incremental updates or diffs. This might happen if you're using a specialised diffing algorithm to process your data."),(0,a.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,a.mdx)("h5",{parentName:"div"},(0,a.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,a.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.mdx)("div",{parentName:"div",className:"admonition-content"},(0,a.mdx)("p",{parentName:"div"},(0,a.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," utilises a familiar Android's ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/support/v7/util/DiffUtil.html"},"DiffUtil"),"."))),(0,a.mdx)("p",null,"Let's use the example of ",(0,a.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/common/SingleComponentSection.html"},"SingleComponentSection")," to describe how to write diff section specs. Here is a snippet of ",(0,a.mdx)("inlineCode",{parentName:"p"},"SingleComponentSectionSpec"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-java"},"@DiffSectionSpec\nclass SingleComponentSectionSpec {\n\n  @OnDiff\n  static void onCreateChangeSet(\n      SectionContext c,\n      ChangeSet changeSet,\n      @Prop Diff<Component> component,\n      ...) {\n\n    if (component.getNext() == null) {\n      changeSet.delete(0);\n    } else if (component.getPrevious() == null) {\n      changeSet.insert(\n          0,\n          ComponentRenderInfo.create()\n              .component(component.getNext())\n              ...\n              .build());\n    } else {\n      changeSet.update(\n          0,\n          ComponentRenderInfo.create()\n              .component(component.getNext())\n              ...\n              .build());\n    }\n  }\n}\n")),(0,a.mdx)("p",null,"As you can see, diff section specs use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"@DiffSectionSpec")," annotation. Implementing a diff section spec requires little boilerplate. You only have to write one method annotated with ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff"),"."),(0,a.mdx)("p",null,"The method annotated with ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff")," must have as its first and second argument a ",(0,a.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/SectionContext.html"},"SectionContext")," and a ",(0,a.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/ChangeSet.html"},"ChangeSet")," respectively. Following these two arguments, your ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff")," method can also accept any number of arguments annotated with ",(0,a.mdx)("inlineCode",{parentName:"p"},"@Prop")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"@State"),"."),(0,a.mdx)("p",null,"These props and state have a special type: ",(0,a.mdx)("inlineCode",{parentName:"p"},"Diff<T>"),".  If your prop is defined in another annotated method like ",(0,a.mdx)("inlineCode",{parentName:"p"},"@Prop String prop1"),", it must be defined as ",(0,a.mdx)("inlineCode",{parentName:"p"},"@Prop Diff<String> prop1")," when being used in the ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff")," method. The reason for this ",(0,a.mdx)("inlineCode",{parentName:"p"},"Diff<T>")," type wrapper is so we can compare previous prop values with new prop values when computing changes."),(0,a.mdx)("h2",{id:"making-changes-to-the-list-with-changeset"},"Making changes to the list with ChangeSet"),(0,a.mdx)("p",null,"The ",(0,a.mdx)("inlineCode",{parentName:"p"},"ChangeSet")," argument of the ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff")," method is used by the Diff section spec to specify how the section changes in response to new data.  The ",(0,a.mdx)("inlineCode",{parentName:"p"},"@OnDiff")," method will always be called with the current ",(0,a.mdx)("em",{parentName:"p"},"and previous")," props and state values (hence the ",(0,a.mdx)("inlineCode",{parentName:"p"},"Diff<T>")," type). The expectation is that you'd be able to use the current and previous values to determine how to update the items being rendered."),(0,a.mdx)("p",null,"When you've determined what changes need to be made, you should call the corresponding method on the ",(0,a.mdx)("inlineCode",{parentName:"p"},"ChangeSet")," object. These methods correspond to ",(0,a.mdx)("inlineCode",{parentName:"p"},"RecyclerView.Adapter"),"'s ",(0,a.mdx)("inlineCode",{parentName:"p"},"notifyItem*")," methods. You can get a quick idea of how this works in ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/litho/blob/d766e3b4965edf84eda0090f58d0020aa302d650/litho-sections-core/src/main/java/com/facebook/litho/sections/common/SingleComponentSectionSpec.java#L25"},"SingleComponentSectionSpec#onDiff"),":"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"If we don't have a new ",(0,a.mdx)("inlineCode",{parentName:"li"},"Component")," (",(0,a.mdx)("inlineCode",{parentName:"li"},"component.getNext() == null"),") then we want to change the list by removing that row."),(0,a.mdx)("li",{parentName:"ul"},"Else if we have a new ",(0,a.mdx)("inlineCode",{parentName:"li"},"Component")," and no previous component, we want to insert a new row."),(0,a.mdx)("li",{parentName:"ul"},"If both an old component and a new component exists, we just want to update that row to the new component.")),(0,a.mdx)("p",null,"Note, the indexes used in the ",(0,a.mdx)("inlineCode",{parentName:"p"},"ChangeSet")," method calls, ",(0,a.mdx)("em",{parentName:"p"},"they're relative to the current section"),".  Index 0 in ",(0,a.mdx)("inlineCode",{parentName:"p"},"SingleComponentSectionSpec")," might actually be index 100 in the final list depending on the section hierarchy. The framework will take care of translating local indexes to global indexes when processing the ",(0,a.mdx)("inlineCode",{parentName:"p"},"ChangeSet"),"."))}m.isMDXComponent=!0}}]);