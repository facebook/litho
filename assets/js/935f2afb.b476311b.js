"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8581],{35610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"mainSidebar":[{"type":"category","label":"What is Litho?","items":[{"type":"link","label":"Motivation","href":"/docs/intro/motivation","docId":"intro/motivation"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Tutorial","items":[{"type":"link","label":"Overview","href":"/docs/tutorial/overview","docId":"tutorial/overview"},{"type":"link","label":"Setting up the Project","href":"/docs/tutorial/project-setup","docId":"tutorial/project-setup"},{"type":"link","label":"Components and Props","href":"/docs/tutorial/first-components","docId":"tutorial/first-components"},{"type":"link","label":"Introducing Layout","href":"/docs/tutorial/introducing-layout","docId":"tutorial/introducing-layout"},{"type":"link","label":"Adding State","href":"/docs/tutorial/adding-state","docId":"tutorial/adding-state"},{"type":"link","label":"Building Lists","href":"/docs/tutorial/building-lists","docId":"tutorial/building-lists"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Main Concepts","items":[{"type":"link","label":"Components","href":"/docs/mainconcepts/components-basics","docId":"mainconcepts/components-basics"},{"type":"link","label":"Types of Props","href":"/docs/mainconcepts/props","docId":"mainconcepts/props"},{"type":"link","label":"Tree Props","href":"/docs/mainconcepts/treeprops","docId":"mainconcepts/treeprops"},{"type":"category","label":"Hooks and State","items":[{"type":"link","label":"Introduction to Hooks","href":"/docs/mainconcepts/hooks-intro","docId":"mainconcepts/hooks-intro"},{"type":"link","label":"useState","href":"/docs/mainconcepts/use-state","docId":"mainconcepts/use-state"},{"type":"link","label":"useEffect","href":"/docs/mainconcepts/use-effect","docId":"mainconcepts/use-effect"},{"type":"link","label":"useRef","href":"/docs/mainconcepts/use-ref","docId":"mainconcepts/use-ref"},{"type":"link","label":"useCached","href":"/docs/mainconcepts/use-cached","docId":"mainconcepts/use-cached"},{"type":"link","label":"useErrorBoundary","href":"/docs/mainconcepts/use-error-boundary","docId":"mainconcepts/use-error-boundary"},{"type":"link","label":"useLiveData","href":"/docs/mainconcepts/use-live-data","docId":"mainconcepts/use-live-data"},{"type":"link","label":"useCallback","href":"/docs/mainconcepts/use-callback","docId":"mainconcepts/use-callback"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Primitive Components","items":[{"type":"link","label":"Overview","href":"/docs/mainconcepts/primitivecomponents/overview","docId":"mainconcepts/primitivecomponents/overview"},{"type":"link","label":"Creating a Primitive Component","href":"/docs/mainconcepts/primitivecomponents/primitive-component","docId":"mainconcepts/primitivecomponents/primitive-component"},{"type":"link","label":"Lifecycle of a Primitive Component","href":"/docs/mainconcepts/primitivecomponents/primitive","docId":"mainconcepts/primitivecomponents/primitive"},{"type":"link","label":"Measuring","href":"/docs/mainconcepts/primitivecomponents/primitive-measuring","docId":"mainconcepts/primitivecomponents/primitive-measuring"},{"type":"link","label":"Controllers Pattern","href":"/docs/mainconcepts/primitivecomponents/primitive-controllers","docId":"mainconcepts/primitivecomponents/primitive-controllers"},{"type":"link","label":"Content Pooling","href":"/docs/mainconcepts/primitivecomponents/primitive-preallocation","docId":"mainconcepts/primitivecomponents/primitive-preallocation"},{"type":"link","label":"Tracing","href":"/docs/mainconcepts/primitivecomponents/primitive-tracing","docId":"mainconcepts/primitivecomponents/primitive-tracing"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Layout System with Flexbox","items":[{"type":"link","label":"Flexbox Attributes","href":"/docs/mainconcepts/flexbox-yoga","docId":"mainconcepts/flexbox-yoga"},{"type":"link","label":"Yoga Playground","href":"/docs/mainconcepts/yoga-playground","docId":"mainconcepts/yoga-playground"},{"type":"link","label":"Flexbox Troubleshooting","href":"/docs/mainconcepts/troubleshooting","docId":"mainconcepts/troubleshooting"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Keys and Component Identity","href":"/docs/mainconcepts/coordinate-state-actions/keys-and-identity","docId":"mainconcepts/coordinate-state-actions/keys-and-identity"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Building Lists","items":[{"type":"link","label":"Introduction","href":"/docs/kotlin/lazycollections/","docId":"kotlin/lazycollections/lazycollections"},{"type":"link","label":"Layout and Styling","href":"/docs/kotlin/lazycollections/lazycollections-layout","docId":"kotlin/lazycollections/lazycollections-layout"},{"type":"link","label":"Interactions","href":"/docs/kotlin/lazycollections/lazycollections-interactions","docId":"kotlin/lazycollections/lazycollections-interactions"},{"type":"link","label":"Working with Updates","href":"/docs/kotlin/lazycollections/lazycollections-working-with-updates","docId":"kotlin/lazycollections/lazycollections-working-with-updates"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Animations","items":[{"type":"link","label":"Animation Basics","href":"/docs/animations/transition-basics","docId":"animations/transition-basics"},{"type":"link","label":"Types of Transitions","href":"/docs/animations/transition-types","docId":"animations/transition-types"},{"type":"link","label":"Animating All Layout","href":"/docs/animations/transition-all-layout","docId":"animations/transition-all-layout"},{"type":"link","label":"Customizing Transitions","href":"/docs/animations/transition-choreography","docId":"animations/transition-choreography"},{"type":"link","label":"Animating View Properties with Dynamic Props","href":"/docs/animations/dynamic-props-bindto","docId":"animations/dynamic-props-bindto"},{"type":"link","label":"Transition Key Scoping","href":"/docs/animations/transition-key-types","docId":"animations/transition-key-types"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Handling Visibility","href":"/docs/mainconcepts/coordinate-state-actions/visibility-handling","docId":"mainconcepts/coordinate-state-actions/visibility-handling"},{"type":"link","label":"Accessibility","href":"/docs/accessibility/","docId":"accessibility/accessibility"},{"type":"category","label":"Testing","items":[{"type":"link","label":"Getting Started","href":"/docs/kotlin/testing-getting-started","docId":"kotlin/testing-getting-started"},{"type":"link","label":"Assertions","href":"/docs/kotlin/testing-assertions","docId":"kotlin/testing-assertions"},{"type":"link","label":"Interactions","href":"/docs/kotlin/testing-actions","docId":"kotlin/testing-actions"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Widgets","items":[{"type":"link","label":"Built-in widgets","href":"/docs/widgets/builtin-widgets","docId":"widgets/builtin-widgets"},{"type":"link","label":"Canvas","href":"/docs/widgets/canvas","docId":"widgets/canvas"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Adopting Litho","items":[{"type":"link","label":"Migration Strategies","href":"/docs/kotlin/migration-strategies","docId":"kotlin/migration-strategies"},{"type":"link","label":"Compatibility with Custom Views","href":"/docs/kotlin/custom-view-compat","docId":"kotlin/custom-view-compat"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Spec APIs","items":[{"type":"link","label":"Introduction","href":"/docs/codegen/overview","docId":"codegen/overview"},{"type":"link","label":"Layout Specs","href":"/docs/codegen/layout-specs","docId":"codegen/layout-specs"},{"type":"link","label":"Mount Specs","href":"/docs/codegen/mount-specs","docId":"codegen/mount-specs"},{"type":"link","label":"Animating View Properties with Dynamic Props","href":"/docs/codegen/dynamic-props","docId":"codegen/dynamic-props"},{"type":"link","label":"More Ways to Define Transitions","href":"/docs/codegen/transition-definitions","docId":"codegen/transition-definitions"},{"type":"link","label":"Making the UI Accessible","href":"/docs/codegen/accessibility-overview","docId":"codegen/accessibility-overview"},{"type":"category","label":"Sections API","items":[{"type":"link","label":"Sections Basics","href":"/docs/sections/start","docId":"sections/start"},{"type":"link","label":"RecyclerCollectionComponent","href":"/docs/sections/recycler-collection-component","docId":"sections/recycler-collection-component"},{"type":"link","label":"Best Practice and Performance","href":"/docs/sections/best-practices","docId":"sections/best-practices"},{"type":"link","label":"Horizontal Scrolling and Measurement","href":"/docs/sections/hscrolls","docId":"sections/hscrolls"},{"type":"category","label":"Advanced","items":[{"type":"link","label":"Prefetch and Pagination","href":"/docs/sections/working-ranges","docId":"sections/working-ranges"},{"type":"link","label":"Scrolling and communicating with the UI","href":"/docs/sections/communicating-with-the-ui","docId":"sections/communicating-with-the-ui"},{"type":"link","label":"Granular Dependency Injection","href":"/docs/sections/services","docId":"sections/services"},{"type":"link","label":"Mixing with Android Views","href":"/docs/sections/view-support","docId":"sections/view-support"},{"type":"link","label":"Writing Your Own DiffSection","href":"/docs/sections/diff-sections","docId":"sections/diff-sections"},{"type":"link","label":"Sections Implementation Architecture","href":"/docs/sections/architecture","docId":"sections/architecture"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Props, State, and Events for Specs","items":[{"type":"link","label":"Props in Specs","href":"/docs/codegen/passing-data-to-components/spec-props","docId":"codegen/passing-data-to-components/spec-props"},{"type":"link","label":"TreeProps","href":"/docs/codegen/passing-data-to-components/treeprops","docId":"codegen/passing-data-to-components/treeprops"},{"type":"link","label":"State in Specs","href":"/docs/codegen/state-for-specs","docId":"codegen/state-for-specs"},{"type":"link","label":"Events for Specs","href":"/docs/codegen/events-for-specs","docId":"codegen/events-for-specs"},{"type":"link","label":"Triggering Events with Handles","href":"/docs/codegen/trigger-events","docId":"codegen/trigger-events"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Coding Style","href":"/docs/codegen/coding-style","docId":"codegen/coding-style"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Migrating to the Kotlin API","items":[{"type":"link","label":"Introduction and Setup","href":"/docs/kotlin/kotlin-intro","docId":"kotlin/kotlin-intro"},{"type":"link","label":"KComponent and Props","href":"/docs/kotlin/kotlin-api-basics","docId":"kotlin/kotlin-api-basics"},{"type":"link","label":"Component Lifecycle and Hooks","href":"/docs/kotlin/hooks-for-spec-developers","docId":"kotlin/hooks-for-spec-developers"},{"type":"link","label":"Transitions","href":"/docs/kotlin/kotlin-transitions","docId":"kotlin/kotlin-transitions"},{"type":"link","label":"Flexbox Containers","href":"/docs/kotlin/kotlin-flexbox-containers","docId":"kotlin/kotlin-flexbox-containers"},{"type":"link","label":"Event Handling","href":"/docs/kotlin/event-handling","docId":"kotlin/event-handling"},{"type":"link","label":"Migrating MountSpecs","href":"/docs/kotlin/migrating-from-mountspecs-to-primitives","docId":"kotlin/migrating-from-mountspecs-to-primitives"},{"type":"link","label":"Migrating Sections","href":"/docs/kotlin/lazycollections/lazycollections-sections-migration","docId":"kotlin/lazycollections/lazycollections-sections-migration"},{"type":"link","label":"Cheatsheet","href":"/docs/kotlin/kotlin-api-cheatsheet","docId":"kotlin/kotlin-api-cheatsheet"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Tooling","items":[{"type":"category","label":"Android Studio","items":[{"type":"link","label":"Litho Android Studio Plugin","href":"/docs/ide/android-studio-plugin","docId":"ide/android-studio-plugin"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Debugging","items":[{"type":"link","label":"Debugging Tips","href":"/docs/debugging/debugging-tips","docId":"debugging/debugging-tips"},{"type":"link","label":"Debugging Sections","href":"/docs/debugging/debugging-sections","docId":"debugging/debugging-sections"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer Tools","items":[{"type":"link","label":"Flipper Plugins","href":"/docs/devtools/flipper-plugins","docId":"devtools/flipper-plugins"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Best Practices","items":[{"type":"link","label":"Immutability","href":"/docs/best-practices/immutability","docId":"best-practices/immutability"},{"type":"link","label":"Props vs. State","href":"/docs/best-practices/props-vs-state","docId":"best-practices/props-vs-state"},{"type":"link","label":"Hoisting State","href":"/docs/mainconcepts/coordinate-state-actions/hoisting-state","docId":"mainconcepts/coordinate-state-actions/hoisting-state"},{"type":"link","label":"Communicating Between Components","href":"/docs/mainconcepts/coordinate-state-actions/communicating-between-components","docId":"mainconcepts/coordinate-state-actions/communicating-between-components"}],"collapsed":true,"collapsible":true}]},"docs":{"accessibility/accessibility":{"id":"accessibility/accessibility","title":"Accessibility","description":"Why Accessibility is important","sidebar":"mainSidebar"},"animations/dynamic-props-bindto":{"id":"animations/dynamic-props-bindto","title":"Animating View Properties with Dynamic Props","description":"Dynamic props are properties that are applied directly to a View or Drawable. They are updated without computing a layout or remounting. This makes them efficient for use in animations or other dynamic UIs. Dynamic props are initialised and updated using DynamicValue.","sidebar":"mainSidebar"},"animations/transition-all-layout":{"id":"animations/transition-all-layout","title":"Animating All Layout","description":"Transition.allLayout() may cause unexpected transitions because it adds transitions to ALL components present in the layout tree, which may include components higher than the target component in the hierarchy. Please use it carefully.","sidebar":"mainSidebar"},"animations/transition-basics":{"id":"animations/transition-basics","title":"Animation Basics","description":"Introduction","sidebar":"mainSidebar"},"animations/transition-choreography":{"id":"animations/transition-choreography","title":"Customizing Transitions","description":"Litho provides several APIs to customise many aspects of transitions and animate different components together.","sidebar":"mainSidebar"},"animations/transition-key-types":{"id":"animations/transition-key-types","title":"Transition Key Scoping","description":"Within the other pages of the \'Animations\' section, a common approach is used when defining transitions: assigning transition keys and creating transitions within a single component declaration.","sidebar":"mainSidebar"},"animations/transition-types":{"id":"animations/transition-types","title":"Types of Transitions","description":"Litho supports animated transitions between two consecutive states of the UI (LayoutStates), which, on this page, are called:","sidebar":"mainSidebar"},"annotation-processor-debugging":{"id":"annotation-processor-debugging","title":"Annotation Processor Debugging","description":"Annotation Processor debugging is a three-step process:"},"architecture-overview":{"id":"architecture-overview","title":"Architecture Overview","description":"Core Concepts"},"asynchronous-layout":{"id":"asynchronous-layout","title":"Asynchronous Layout","description":"Immutability and Thread Safety"},"best-practices/immutability":{"id":"best-practices/immutability","title":"Immutability","description":"Components are essentially functions that receive data as parameters and are immutable (cannot be changed). When the props or state of a component change, the framework will create a new component instance with the updated information, because the previous component cannot be mutated.","sidebar":"mainSidebar"},"best-practices/props-vs-state":{"id":"best-practices/props-vs-state","title":"Props vs. State","description":"Litho components have two types of data model: Props and State.","sidebar":"mainSidebar"},"borders":{"id":"borders","title":"Borders","description":"Litho provides extensive support for stylized borders on component layouts. All of the available options are specified through a Border object via a builder pattern."},"cached-values":{"id":"cached-values","title":"Cached Values","description":"The purpose of the Cached Values API is to provide caching within Spec classes, rather than have to repeatedly make an expensive calculation or to use lazy state updates for this purpose."},"codegen":{"id":"codegen","title":"Code Generation","description":"As explained in Writing Components, Litho relies on code generation in order to create Components from Component Specs. This process utilises intermediate ComponentSpec representations called SpecModels, which are immutable java objects."},"codegen/accessibility-overview":{"id":"codegen/accessibility-overview","title":"Making the UI Accessible","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"codegen/coding-style":{"id":"codegen/coding-style","title":"Coding Style","description":"This page contains Best Practice guidelines for styling code.","sidebar":"mainSidebar"},"codegen/dynamic-props":{"id":"codegen/dynamic-props","title":"Animating View Properties with Dynamic Props","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"codegen/events-for-specs":{"id":"codegen/events-for-specs","title":"Events for Specs","description":"The framework provides a general-purpose API to connect components through events. Events are declared as a POJO (Plain Old Java Object) with an @Event annotation. By convention, Event class names are suffixed with Event.","sidebar":"mainSidebar"},"codegen/layout-specs":{"id":"codegen/layout-specs","title":"Layout Specs","description":"This page covers the old Java Spec API. If you\'re not using the Spec API, refer to the Components page.","sidebar":"mainSidebar"},"codegen/mount-specs":{"id":"codegen/mount-specs","title":"Mount Specs","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"codegen/overview":{"id":"codegen/overview","title":"Introduction","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"codegen/passing-data-to-components/spec-props":{"id":"codegen/passing-data-to-components/spec-props","title":"Props in Specs","description":"This page covers the old Java Spec API. If the Spec API is not being used, refer to the Components page.","sidebar":"mainSidebar"},"codegen/passing-data-to-components/treeprops":{"id":"codegen/passing-data-to-components/treeprops","title":"TreeProps","description":"This page covers the old Java Spec API. If the Spec API is not being used, refer to the TreeProps section of the \'Types of Props\' page.","sidebar":"mainSidebar"},"codegen/state-for-specs":{"id":"codegen/state-for-specs","title":"State in Specs","description":"This page introduces the concept of state in a component written using the Java Spec API, namely a @LayoutSpec or @MountSpec.","sidebar":"mainSidebar"},"codegen/transition-definitions":{"id":"codegen/transition-definitions","title":"More Ways to Define Transitions","description":"@State Arguments","sidebar":"mainSidebar"},"codegen/trigger-events":{"id":"codegen/trigger-events","title":"Triggering Events with Handles","description":"A Handle is a unique identifier that can be shared with other components by passing it as a @Prop.","sidebar":"mainSidebar"},"common-props":{"id":"common-props","title":"Common Props","description":"This page contains a detailed API reference for the Litho\'s component common props. It assumes you\u2019re familiar with fundamental Litho concepts, such as LayoutSpecs, Props, and State. If you\u2019re not, read them first."},"community-showcase":{"id":"community-showcase","title":"Community Showcase","description":"This is a selection of community contributions to Litho and projects."},"contributing":{"id":"contributing","title":"How to Contribute","description":"The Facebook Litho team would love to have your contributions."},"custom-layout":{"id":"custom-layout","title":"Manual Measurement","description":"Litho relies on Yoga, a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic."},"debugging/debugging-sections":{"id":"debugging/debugging-sections","title":"Debugging Sections","description":"This page acts as a debugging guide that explains how to read the operations performed when an event occurs in a Litho Sections surface with the Flipper Sections plugin. This helps to debug common issues such as unwanted scrolling and items getting re-rendered incorrectly.","sidebar":"mainSidebar"},"debugging/debugging-tips":{"id":"debugging/debugging-tips","title":"Debugging Tips","description":"Flipper","sidebar":"mainSidebar"},"deep-dive/incremental-mount":{"id":"deep-dive/incremental-mount","title":"Incremental Mount","description":"Even though components provide flatter view hierarchies and perform layout off the main thread, the mount operation (creating, recycling and attaching views and drawables) can still have a cost in the UI thread for very complex components, especially for the ones containing many views."},"deep-dive/reconciliation":{"id":"deep-dive/reconciliation","title":"Introduction","description":"Reconciliation is an implementation detail in Litho\u2019s layout calculation process. Instead of recreating the entire layout tree for every update, reconciliation enables Litho to clone the"},"deep-dive/reconciliation/enabling-reconciliation":{"id":"deep-dive/reconciliation/enabling-reconciliation","title":"Enabling Reconciliation","description":"Reconciliation is enabled by default."},"devtools/android-studio-plugin":{"id":"devtools/android-studio-plugin","title":"Android Studio Plugin","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"devtools/flipper-plugins":{"id":"devtools/flipper-plugins","title":"Flipper Plugins","description":"When you create or debug standard Android Views, you can use the \'Layout Preview\' and the \'Layout Inspector\' tools from Android Studio. However, since Litho operates with different UI primitives, such as \'Components\' and \'Sections\', those standard tools are not very useful in such cases.","sidebar":"mainSidebar"},"events-touch-handling":{"id":"events-touch-handling","title":"Touch Handling","description":"All components support touch handling through the framework\'s event system. All components can handle the following events by default: ClickEvent, LongClickEvent, and TouchEvent."},"faq":{"id":"faq","title":"FAQ","description":"Frequently Asked Questions"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"<Tabs"},"glossary":{"id":"glossary","title":"Glossary","description":"Spec? Prop? State? Tree? What do all of these terms mean when it comes to Litho and Section Components?"},"ide/android-studio-plugin":{"id":"ide/android-studio-plugin","title":"Litho Android Studio Plugin","description":"Litho Kotlin API","sidebar":"mainSidebar"},"intro":{"id":"intro","title":"What is Litho?","description":"Litho is a declarative framework for building efficient user interfaces (UI) on"},"intro/built-with-litho":{"id":"intro/built-with-litho","title":"Built with Litho","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"intro/motivation":{"id":"intro/motivation","title":"Motivation","description":"Building a list interface on Android is fairly simple. Just create a layout for","sidebar":"mainSidebar"},"kotlin/custom-view-compat":{"id":"kotlin/custom-view-compat","title":"Compatibility with Custom Views","description":"This section contains information about the old Java Spec API.","sidebar":"mainSidebar"},"kotlin/event-handling":{"id":"kotlin/event-handling","title":"Event Handling","description":"There are three scenarios in which the use of Event Handlers is different in the Kotlin API:","sidebar":"mainSidebar"},"kotlin/hooks-for-spec-developers":{"id":"kotlin/hooks-for-spec-developers","title":"Component Lifecycle and Hooks","description":"This page covers how to convert existing code from lifecycle methods in the Specs API to hooks in the Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-api-basics":{"id":"kotlin/kotlin-api-basics","title":"KComponent and Props","description":"This page details how to convert existing components with @LayoutSpecs to Kotlin KComponent.","sidebar":"mainSidebar"},"kotlin/kotlin-api-cheatsheet":{"id":"kotlin/kotlin-api-cheatsheet","title":"Cheatsheet","description":"The following cheatsheet provides a set of links for the migration of individual aspects of existing code from the Spec API to the Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-flexbox-containers":{"id":"kotlin/kotlin-flexbox-containers","title":"Flexbox Containers","description":"This page covers how to convert existing code from the Spec API to the Kotlin API.","sidebar":"mainSidebar"},"kotlin/kotlin-intro":{"id":"kotlin/kotlin-intro","title":"Introduction and Setup","description":"Introduction","sidebar":"mainSidebar"},"kotlin/kotlin-transitions":{"id":"kotlin/kotlin-transitions","title":"Transitions","description":"Transitions are an important concept in Litho, and the Kotlin API provides a set of powerful hooks for transition support. This makes it possible to replicate the behaviors of both @OnCreateTransition and @OnUpdateStateWithTransition in Kotlin.","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections":{"id":"kotlin/lazycollections/lazycollections","title":"Introduction","description":"Lazy Collections are a Kotlin-only API. Within Litho, lists are implemented using the Lazy Collection API.","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-interactions":{"id":"kotlin/lazycollections/lazycollections-interactions","title":"Interactions","description":"Within Litho, lists are implemented using the Lazy Collection API.","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-layout":{"id":"kotlin/lazycollections/lazycollections-layout","title":"Layout and Styling","description":"Within Litho, lists are implemented using the Lazy Collection API.","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-sections-migration":{"id":"kotlin/lazycollections/lazycollections-sections-migration","title":"Migrating Sections","description":"This page provides guidance for migrating an existing list rendered with Sections to Lazy Collections.","sidebar":"mainSidebar"},"kotlin/lazycollections/lazycollections-working-with-updates":{"id":"kotlin/lazycollections/lazycollections-working-with-updates","title":"Working with Updates","description":"Within Litho, lists are implemented using the Lazy Collection API.","sidebar":"mainSidebar"},"kotlin/migrating-from-mountspecs-to-primitives":{"id":"kotlin/migrating-from-mountspecs-to-primitives","title":"Migrating MountSpecs","description":"This page outlines the process of migrating from MountSpecs to Primitive Components.","sidebar":"mainSidebar"},"kotlin/migration-strategies":{"id":"kotlin/migration-strategies","title":"Migration Strategies","description":"Prerequisites","sidebar":"mainSidebar"},"kotlin/testing-actions":{"id":"kotlin/testing-actions","title":"Interactions","description":"An Interaction is defined as any type of action that a user can perform on Components. A good example is touching or clicking a Button.","sidebar":"mainSidebar"},"kotlin/testing-assertions":{"id":"kotlin/testing-assertions","title":"Assertions","description":"It\'s possible to use AssertJ-style APIs to assert what gets rendered by a Component or LithoView. All of the Component and LithoView assertions are exposed in LithoAssertions.assertThat() methods.","sidebar":"mainSidebar"},"kotlin/testing-getting-started":{"id":"kotlin/testing-getting-started","title":"Getting Started","description":"The Litho Testing API is presented through the LithoTestRule class, it enables the following:","sidebar":"mainSidebar"},"mainconcepts/components-basics":{"id":"mainconcepts/components-basics","title":"Components","description":"What is a component?","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/communicating-between-components":{"id":"mainconcepts/coordinate-state-actions/communicating-between-components","title":"Communicating Between Components","description":"Dispatching an Event from a child to its parent","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/componenttree":{"id":"mainconcepts/coordinate-state-actions/componenttree","title":"ComponentTree","description":"In the Using Components guide, we saw how you can create a root component and pass it to a LithoView, which will take care of creating a ComponentTree with the given root. ComponentTree manages your component\'s lifecycle in a thread-safe way. You can create and make calls to it from any thread."},"mainconcepts/coordinate-state-actions/hoisting-state":{"id":"mainconcepts/coordinate-state-actions/hoisting-state","title":"Hoisting State","description":"Often, several components need to reflect the same changing value. Rather than a state for each component, it is better to host a single state in their closest common ancestor.","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/keys-and-identity":{"id":"mainconcepts/coordinate-state-actions/keys-and-identity","title":"Keys and Component Identity","description":"Explains how Component identity works in Litho using keys and why manual keys are sometimes necessary.","sidebar":"mainSidebar"},"mainconcepts/coordinate-state-actions/visibility-handling":{"id":"mainconcepts/coordinate-state-actions/visibility-handling","title":"Handling Visibility","description":"Describes the APIs to handle visibility of components","sidebar":"mainSidebar"},"mainconcepts/flexbox-yoga":{"id":"mainconcepts/flexbox-yoga","title":"Flexbox Attributes","description":"Litho uses the Yoga library, which is an implementation of Flexbox, to measure and layout on-screen components. Users familiar with Flexbox on the web should have no problems. For users familiar with how Android normally performs Layout, Flexbox will remind them of LinearLayout.","sidebar":"mainSidebar"},"mainconcepts/hooks-intro":{"id":"mainconcepts/hooks-intro","title":"Introduction to Hooks","description":"Definition: Hooks are special functions that can persist state across renders and perform side-effects . They begin with use and may only be called from render() and other hooks. The API is heavily inspired by React Hooks.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/overview":{"id":"mainconcepts/primitivecomponents/overview","title":"Overview","description":"Primitive Components are used to render views or drawables, and should only be created when you need to integrate your own views/drawables with Litho.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive":{"id":"mainconcepts/primitivecomponents/primitive","title":"Lifecycle of a Primitive Component","description":"A Primitive represents a reusable unit responsible for hosting the logic to create, measure, and mount the content that the Primitive Component will render.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive-component":{"id":"mainconcepts/primitivecomponents/primitive-component","title":"Creating a Primitive Component","description":"Primitive Components can be used to render views or drawables on the screen.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive-controllers":{"id":"mainconcepts/primitivecomponents/primitive-controllers","title":"Controllers Pattern","description":"The Controllers Pattern can be used to control the content from outside the component, typically from an ancestor, and for communication between the parent and children Components. A Controller is an object that can control the Primitive Component\'s content (a View or a Drawable) independently of the Component itself. In the example described below, the Controller is used to read and write the minute and hour values of the TimePicker view. The same instance of the Controller object is shared between the parent Component and both of its children, which allows children for controlling parent\'s behavior.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive-measuring":{"id":"mainconcepts/primitivecomponents/primitive-measuring","title":"Measuring","description":"Primitive should provide an implementation of LayoutBehavior interface to define how it should measure itself, based on the provided SizeConstraints.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive-preallocation":{"id":"mainconcepts/primitivecomponents/primitive-preallocation","title":"Content Pooling","description":"When a Primitive Component is being mounted, its content (View or Drawable) needs to be either initialized or reused from the recycling pool. If the pool is empty, a new instance will be created at that time, which might keep the UI thread too busy and drop one or more frames. To mitigate that, the Litho framework can pre-allocate a few instances and put them in the recycling pool to improve performance.","sidebar":"mainSidebar"},"mainconcepts/primitivecomponents/primitive-tracing":{"id":"mainconcepts/primitivecomponents/primitive-tracing","title":"Tracing","description":"On Android, Systrace is a standard tool for analyzing app performance. The developer can add traces around parts of the code that need to be measured. Android OS adds some tracing out of the box, and similarly Litho adds traces for common operations such as binding/unbinding data to and from UI.","sidebar":"mainSidebar"},"mainconcepts/props":{"id":"mainconcepts/props","title":"Types of Props","description":"The Components page details how to declare a component and its props as standard val properties. This page covers two more ways for a parent component to configure its children with props: Common props and Tree props.","sidebar":"mainSidebar"},"mainconcepts/treeprops":{"id":"mainconcepts/treeprops","title":"Tree Props","description":"The Types of Props page details different types of Litho props. This page covers one more type of props - Tree Props.","sidebar":"mainSidebar"},"mainconcepts/troubleshooting":{"id":"mainconcepts/troubleshooting","title":"Flexbox Troubleshooting","description":"A few issues may be encountered while using flexbox. This section discusses the more common of those issues, which may prove useful when debugging and finding issues in layout.","sidebar":"mainSidebar"},"mainconcepts/use-cached":{"id":"mainconcepts/use-cached","title":"useCached","description":"useCached is a hook that, rather than have to repeatedly make an expensive calculation, enables a component to calculate and maintain a cached value. It is calculated when the component is first added to the ComponentTree, and only recalculated when any of the dependencies provided in the useCached declaration changes.","sidebar":"mainSidebar"},"mainconcepts/use-callback":{"id":"mainconcepts/use-callback","title":"useCallback","description":"useCallback is a hook that allows a parent to pass a child component a callback which:","sidebar":"mainSidebar"},"mainconcepts/use-effect":{"id":"mainconcepts/use-effect","title":"useEffect","description":"useEffect is a hook that allows a component to perform side-effects when it\'s attached and/or detached from the tree, or in response to changes in committed props or state.","sidebar":"mainSidebar"},"mainconcepts/use-error-boundary":{"id":"mainconcepts/use-error-boundary","title":"useErrorBoundary","description":"useErrorBoundary enables components to catch and handle errors higher up in the tree and provide appropriate fallback, logging or retry mechanisms.","sidebar":"mainSidebar"},"mainconcepts/use-live-data":{"id":"mainconcepts/use-live-data","title":"useLiveData","description":"How does Litho support LiveData","sidebar":"mainSidebar"},"mainconcepts/use-ref":{"id":"mainconcepts/use-ref","title":"useRef","description":"useRef is a hook that allows a component to maintain a mutable reference that doesn\'t trigger a re-render when updated. It returns an instance of Ref which has a single mutable value property, which should only be read/written on the UI thread.","sidebar":"mainSidebar"},"mainconcepts/use-state":{"id":"mainconcepts/use-state","title":"useState","description":"useState is a hook that allows a component to persist and update a single value across renders and is the most common hook you\'ll encounter.","sidebar":"mainSidebar"},"mainconcepts/yoga-playground":{"id":"mainconcepts/yoga-playground","title":"Yoga Playground","description":"The Yoga Playground can be used to try different layout configurations and generate corresponding Litho code, as shown in the following screenshot.","sidebar":"mainSidebar"},"mount-extensions":{"id":"mount-extensions","title":"Mount Extensions","description":"Mount Extensions are a way of modularising Litho\u2019s default behaviour, as it\u2019s being changed from a monolithic framework to a modular framework that\u2019s split into the rendering engine (RenderCore) and extensions for custom behaviour."},"onattached-ondetached":{"id":"onattached-ondetached","title":"OnAttached/OnDetached","description":"Sometimes we would like the component to subscribe a listener when it\'s available and unsubscribe the listener when the component is unavailable. Usually we can use VisibleEvent and InvisibleEvent handlers to subscribe/unsubscribe listeners."},"performance/analysing-performance":{"id":"performance/analysing-performance","title":"Analysing Performance","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION"},"recycling":{"id":"recycling","title":"Recycling","description":"Device screens typically refresh at a rate of 60 frames per second. To provide smooth performances, an app needs to be able to render changes to our UI continuously every 16ms. Failing to respect this time constraint leads to dropped frames and poor user experience."},"repo-structure":{"id":"repo-structure","title":"Repository Structure","description":"This is a quick breakdown of what is where in the repository."},"saving-state":{"id":"saving-state","title":"Saving state on rotation","description":"Saving state on app configuration changes"},"sections-tutorial":{"id":"sections-tutorial","title":"Sections Tutorial","description":"This part builds on the work you did in the litho tutorial. Make sure you\'ve read through that tutorial before returning to this one."},"sections/architecture":{"id":"sections/architecture","title":"Sections Implementation Architecture","description":"At its core, the Sections framework is responsible for producing a ChangeSet from immutable props and a hierarchy of Sections. The framework produces these ChangeSets by creating a new section hierarchy whenever a SectionTree is set with a Section with new props, or whenever a Section in the hierarchy updates its internal state when comparing the new hierarchy with the old hierarchy.","sidebar":"mainSidebar"},"sections/best-practices":{"id":"sections/best-practices","title":"Best Practice and Performance","description":"This page covers the older Java codegen-based Sections API. If using the Kotlin Lazy Collection API, refer to the Working with Updates page in the \'Building Lists\' section.","sidebar":"mainSidebar"},"sections/communicating-with-the-ui":{"id":"sections/communicating-with-the-ui","title":"Scrolling and communicating with the UI","description":"This page covers the older Java codegen-based Sections API. If using the Kotlin Lazy Collection API, refer to the interactions docs for Lazy Collection for similar relevant content.","sidebar":"mainSidebar"},"sections/diff-sections":{"id":"sections/diff-sections","title":"Writing Your Own DiffSection","description":"This page contains information needed to build a bespoke DiffSection.","sidebar":"mainSidebar"},"sections/hscrolls":{"id":"sections/hscrolls","title":"Horizontal Scrolling and Measurement","description":"This page covers the older Java codegen-based Sections API. If you\'re using the Kotlin Lazy Collection API, refer to the layout docs for Lazy Collection.","sidebar":"mainSidebar"},"sections/recycler-collection-component":{"id":"sections/recycler-collection-component","title":"RecyclerCollectionComponent","description":"This page covers the older Java codegen-based Sections API. If creating a new list in Kotlin, refer to the Lazy Collection docs.","sidebar":"mainSidebar"},"sections/services":{"id":"sections/services","title":"Granular Dependency Injection","description":"Values such as @Prop flow through Sections before being rendered on-screen. The Sections API sits between a data source and the UI components to efficiently calculate the changesets that are needed to render the components. For better performance, only do work at the layer where it\'s required.","sidebar":"mainSidebar"},"sections/start":{"id":"sections/start","title":"Sections Basics","description":"This page covers the older Java codegen-based Sections API. If creating a new list in Kotlin, refer to the Lazy Collection docs.","sidebar":"mainSidebar"},"sections/view-support":{"id":"sections/view-support","title":"Mixing with Android Views","description":"Sections work best when combined with the rendering optimisations that Litho components offer. However, the API also provides support for rendering Android Views instead of (or along with) components. This makes the transition to Sections easier. The advantages of the improved performance are still available regardless of the product\'s UI using traditional Android Views, Litho components or a mix of the two.","sidebar":"mainSidebar"},"sections/working-ranges":{"id":"sections/working-ranges","title":"Prefetch and Pagination","description":"This page covers the older Java codegen-based Sections API. If using the Kotlin Lazy Collection API, refer to the interactions docs for Lazy Collection for similar relevant content.","sidebar":"mainSidebar"},"styles":{"id":"styles","title":"Styles","description":"Components can have their props come from regular Android style resources in a similar way to an Android View\'s AttributeSet constructor. It enables developers to define static prop values or prop defaults directly from style resources."},"testing/espresso-testing":{"id":"testing/espresso-testing","title":"End-to-End Tests","description":"Litho provides basic support for the"},"testing/event-handler-testing":{"id":"testing/event-handler-testing","title":"Event Handler Testing","description":"This document provides a quick example of how to write tests for your event"},"testing/prop-matching":{"id":"testing/prop-matching","title":"Matching @Prop","description":"For help with setting up the Test environment, see the Getting Started page."},"testing/sections-testing":{"id":"testing/sections-testing","title":"Testing Sections","description":"The SectionsTestHelper provides easy-to-use helper functions to test the output of GroupSectionSpecs and state updates."},"testing/subcomponent-testing":{"id":"testing/subcomponent-testing","title":"Sub-Component Testing","description":"The Getting Started page contains information to help you setup your test environment."},"testing/testing-overview":{"id":"testing/testing-overview","title":"Introduction","description":"This page contains a brief overview of the variety of tools, provided by Litho, to write different types of tests."},"testing/testing-treeprops":{"id":"testing/testing-treeprops","title":"Matching @TreeProp","description":"For help with setting up the test environment, see the Getting Started page."},"testing/tests-in-android-studio":{"id":"testing/tests-in-android-studio","title":"Testing in Android Studio","description":"The Litho repository can be used with both Buck and Gradle. The Buck plugin for"},"testing/unit-testing":{"id":"testing/unit-testing","title":"Getting Started","description":"To use any of the testing utilities, include the litho-testing package in your build."},"tooltips":{"id":"tooltips","title":"Tooltips","description":"Litho tooltip APIs provide methods for displaying a floating view anchored to a component in your hierarchy."},"tutorial":{"id":"tutorial","title":"Tutorial","description":"This tutorial assumes you\'ve gone through the Getting Started guide to set up Litho.  Make sure you set up Litho\'s core libraries and Sections\' libraries."},"tutorial/adding-state":{"id":"tutorial/adding-state","title":"Adding State","description":"In this section of the tutorial, you\'ll learn about useState, one of Litho\'s Hooks.","sidebar":"mainSidebar"},"tutorial/building-lists":{"id":"tutorial/building-lists","title":"Building Lists","description":"\ud83d\udea7\xa0\xa0\xa0THIS PAGE IS UNDER CONSTRUCTION","sidebar":"mainSidebar"},"tutorial/first-components":{"id":"tutorial/first-components","title":"Components and Props","description":"In this section of the tutorial, you\'ll learn the basic Litho building blocks then create your first component that uses props.","sidebar":"mainSidebar"},"tutorial/introducing-layout":{"id":"tutorial/introducing-layout","title":"Introducing Layout","description":"In this section of the tutorial, you\'ll become familiar with building layouts using Flexbox in Litho for an Instagram post component.","sidebar":"mainSidebar"},"tutorial/overview":{"id":"tutorial/overview","title":"Overview","description":"This tutorial doesn\u2019t assume you have existing Litho knowledge.","sidebar":"mainSidebar"},"tutorial/project-setup":{"id":"tutorial/project-setup","title":"Setting up the Project","description":"After creating an Android app project in Android Studio, take the steps detailed in this page to configure it with the correct settings and dependencies.","sidebar":"mainSidebar"},"updating-ui":{"id":"updating-ui","title":"Updating the UI","description":"Components and immutability"},"uses":{"id":"uses","title":"Uses","description":"Litho\'s primary use case is RecyclerViews with complex content as it delivers"},"using-components":{"id":"using-components","title":"Using Components","description":"Generated component classes provide a simple builder with the props you defined in your component spec. In order to use the generated component in your UI, you\'ll need a LithoView, which is an Android ViewGroup that is able to render components."},"view-flattening":{"id":"view-flattening","title":"View Flattening","description":"Let\'s take a look at the layout in the example below. It contains an image, a title and subtitle. With the traditional Android View system, you would have a view for all these elements, wrapped in a few view groups for arranging the items."},"widgets/builtin-widgets":{"id":"widgets/builtin-widgets","title":"Built-in widgets","description":"This page covers the basic built-in widgets. For the full list of components and APIs, see the com.facebook.litho.widget package in javadocs.","sidebar":"mainSidebar"},"widgets/canvas":{"id":"widgets/canvas","title":"Canvas","description":"The Canvas component provides a means for drawing simple 2D graphics. It has many uses, including drawing decorations, backgrounds, data visualization, and animation.","sidebar":"mainSidebar"},"writing-components":{"id":"writing-components","title":"Writing Components","description":"Component Specs"}}}')}}]);