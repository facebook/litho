"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1335],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>c,mdx:()=>w,useMDXComponents:()=>s,withMDXComponents:()=>m});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i.apply(this,arguments)}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),m=function(e){return function(n){var t=s(n.components);return o.createElement(e,i({},n,{components:t}))}},s=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},c=function(e){var n=s(e.components);return o.createElement(l.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},f=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=s(t),c=r,u=m["".concat(a,".").concat(c)]||m[c]||h[c]||i;return t?o.createElement(u,d(d({ref:n},l),{},{components:t})):o.createElement(u,d({ref:n},l))}));function w(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=f;var d={};for(var p in n)hasOwnProperty.call(n,p)&&(d[p]=n[p]);d.originalType=e,d[u]="string"==typeof e?e:r,a[1]=d;for(var l=2;l<i;l++)a[l]=t[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}f.displayName="MDXCreateElement"},41533:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>s});var o=t(87462),r=t(63366),i=(t(67294),t(3905)),a=["components"],d={id:"view-support",title:"Mixing with Android Views"},p=void 0,l={unversionedId:"sections/view-support",id:"sections/view-support",title:"Mixing with Android Views",description:"Sections work best when combined with the rendering optimisations that Litho components offer. However, the API also provides support for rendering Android Views instead of (or along with) components. This makes the transition to Sections easier. The advantages of the improved performance are still available regardless of the product's UI using traditional Android Views, Litho components or a mix of the two.",source:"@site/../docs/sections/view-support.md",sourceDirName:"sections",slug:"/sections/view-support",permalink:"/docs/sections/view-support",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/sections/view-support.md",tags:[],version:"current",frontMatter:{id:"view-support",title:"Mixing with Android Views"},sidebar:"mainSidebar",previous:{title:"Granular Dependency Injection",permalink:"/docs/sections/services"},next:{title:"Writing Your Own DiffSection",permalink:"/docs/sections/diff-sections"}},m={},s=[{value:"ViewRenderInfo",id:"viewrenderinfo",level:3},{value:"Mixing components and views",id:"mixing-components-and-views",level:3}],c={toc:s},u="wrapper";function h(e){var n=e.components,t=(0,r.Z)(e,a);return(0,i.mdx)(u,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Sections work best when combined with the rendering optimisations that Litho components offer. However, the API also provides ",(0,i.mdx)("strong",{parentName:"p"},"support for rendering Android")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"View"),"s instead of (or along with) components. This makes the transition to Sections easier. The advantages of the improved performance are still available regardless of the product's UI using traditional Android Views, Litho components or a mix of the two."),(0,i.mdx)("p",null,"View support is available only through ",(0,i.mdx)("a",{parentName:"p",href:"/docs/sections/start#datadiffsection"},"DataDiffSection"),"."),(0,i.mdx)("p",null,"The following code shows how to declare what the framework should render for a certain item:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@GroupSectionSpec\nclass MyGroupSectionSpec {\n\n  @OnCreateChildren\n  static Children onCreateChildren(\n      SectionContext c,\n      @Prop ImmutableList<MyModel> dataModel) {\n      return Children.create()\n          .child(\n              DataDiffSection.<MyModel>create(c)\n                .data(dataModel)\n                .renderEventHandler(MyGroupSection.onRenderEvent(c)))\n          .build();\n  }\n\n  @OnEvent(RenderEvent.class)\n  static RenderInfo onRenderEvent(\n      SectionContext c,\n      @FromEvent MyModel model) {\n      return ComponentRenderInfo.create()\n          .component(MyModelItemComponent.create(c).item(model).build())\n          .build();\n  }\n}\n")),(0,i.mdx)("p",null,"When an item needs to be rendered on-screen, the framework dispatches a ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," and calls the event handler passed as prop to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," to create a ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderInfo")," for that item. ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderInfo")," holds information that allows the framework to understand how a certain item should be rendered."),(0,i.mdx)("h3",{id:"viewrenderinfo"},"ViewRenderInfo"),(0,i.mdx)("p",null,"The most commonly used implementation of ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderInfo")," is ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/widget/ComponentRenderInfo.html"},"ComponentRenderInfo"),". The GroupSectionSpec above shows how it can be used to declare an item to be rendered using Litho Components. To render items with views instead, just return a different ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderInfo")," implementation, namely a ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/widget/ViewRenderInfo.html"},(0,i.mdx)("inlineCode",{parentName:"a"},"ViewRenderInfo"))," instance, from the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," handler, as shown in the following code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@OnEvent(RenderEvent.class)\nstatic RenderInfo onRenderEvent(\n    SectionContext c,\n    @FromEvent MyModel model,\n    @FromEvent int index) {\n    return ViewRenderInfo.create(c)\n        .viewCreator(VIEW_CREATOR)\n        .viewBinder(VIEW_BINDER)\n        .build();\n}\n")),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"ViewRenderInfo")," has two mandatory props that need to be passed to it: a ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/viewcompat/ViewCreator.html"},"ViewCreator")," and a ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/viewcompat/ViewBinder.html"},"ViewBinder"),". These props are the logical equivalent of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"onCreateViewHolder()")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"onBindViewHolder()")," methods of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RecyclerView.Adapter"),"."),(0,i.mdx)("p",null,"The framework provides a no-op implementation of ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewBinder"),", called ",(0,i.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/viewcompat/SimpleViewBinder.html"},"SimpleViewBinder"),", that can be used if there is a need to implement only one of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewBinder")," methods, typically ",(0,i.mdx)("inlineCode",{parentName:"p"},"bind(View)"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"private static SimpleViewBinder VIEW_BINDER =\n    new SimpleViewBinder<MyView>() {\n        @Override\n        public void bind(MyView view) {\n        // this call is equivalent to onBindViewHolder()\n        }\n    };\n")),(0,i.mdx)("p",null,"Views created by the same ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewCreator")," instance will be recycled in the same pool in ",(0,i.mdx)("inlineCode",{parentName:"p"},"RecyclerView"),". You can create a static instance of ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewCreator")," for different view types, which you will use in the sections, then pass a static instance to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewRenderInfo.Builder#viewCreator()")," method to ensure efficient recycling. You can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"model")," or the ",(0,i.mdx)("inlineCode",{parentName:"p"},"index")," parameters in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," handler to decide amongst multiple view types and return the appropriate ",(0,i.mdx)("inlineCode",{parentName:"p"},"ViewCreator")," instance:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"private static ViewCreator VIEW_CREATOR =\n    new ViewCreator<MyView>() {\n        @Override\n        public MyView createView(Context c, ViewGroup parent) {\n            // this call is equivalent to onCreateViewHolder()\n            return new MyView(c);\n        }\n    };\n")),(0,i.mdx)("h3",{id:"mixing-components-and-views"},"Mixing components and views"),(0,i.mdx)("p",null,"If the Section needs to render items with a mixture of Litho components and views, it can be achieved by returning the appropriate ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderInfo")," implementation from the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," handler, as shown in the following code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@OnEvent(RenderEvent.class)\nstatic RenderInfo onRenderEvent(\n    SectionContext c,\n    @FromEvent MyModel model) {\n    if (model.canRenderWithComponent()) {\n        return ComponentRenderInfo.create()\n            .component(MyModelItemComponent.create(c).item(model).build())\n            .build();\n    }\n\n    return ViewRenderInfo.create(c)\n            .viewCreator(VIEW_CREATOR)\n            .viewBinder(\n                new SimpleViewBinder<MyView>() {\n                    @Override\n                    public void bind(MyView view) {\n                        // this call is equivalent to onBindViewHolder()\n                    }\n                })\n            .build();\n}\n")))}h.isMDXComponent=!0}}]);