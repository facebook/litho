"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8967],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>l,MDXProvider:()=>m,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>p});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){return function(t){var n=d(t.components);return a.createElement(e,r({},t,{components:n}))}},d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,h=p["".concat(o,".").concat(m)]||p[m]||u[m]||r;return n?a.createElement(h,c(c({ref:t},l),{},{components:n})):a.createElement(h,c({ref:t},l))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[h]="string"==typeof e?e:i,o[1]=c;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},96290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>c,metadata:()=>l,toc:()=>d});var a=n(58168),i=n(98587),r=(n(96540),n(15680)),o=["components"],c={id:"architecture",title:"Sections Implementation Architecture"},s=void 0,l={unversionedId:"sections/architecture",id:"sections/architecture",title:"Sections Implementation Architecture",description:"At its core, the Sections framework is responsible for producing a ChangeSet from immutable props and a hierarchy of Sections. The framework produces these ChangeSets by creating a new section hierarchy whenever a SectionTree is set with a Section with new props, or whenever a Section in the hierarchy updates its internal state when comparing the new hierarchy with the old hierarchy.",source:"@site/../docs/sections/architecture.md",sourceDirName:"sections",slug:"/sections/architecture",permalink:"/docs/sections/architecture",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/sections/architecture.md",tags:[],version:"current",frontMatter:{id:"architecture",title:"Sections Implementation Architecture"},sidebar:"mainSidebar",previous:{title:"Writing Your Own DiffSection",permalink:"/docs/sections/diff-sections"},next:{title:"Props in Specs",permalink:"/docs/codegen/passing-data-to-components/spec-props"}},p={},d=[{value:"What is a SectionTree?",id:"what-is-a-sectiontree",level:2},{value:"Updating the SectionTree",id:"updating-the-sectiontree",level:2},{value:"Computing ChangeSets",id:"computing-changesets",level:2},{value:"Generating Trees",id:"generating-trees",level:3},{value:"Generating a Changeset",id:"generating-a-changeset",level:3},{value:"SectionTree and the RecyclerCollectionComponent",id:"sectiontree-and-the-recyclercollectioncomponent",level:3}],m={toc:d},h="wrapper";function u(e){var t=e.components,n=(0,i.A)(e,o);return(0,r.mdx)(h,(0,a.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"At its core, the Sections framework is responsible for producing a ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/ChangeSet.html"},"ChangeSet")," from immutable props and a hierarchy of ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/Section.html"},"Sections"),". The framework produces these ",(0,r.mdx)("inlineCode",{parentName:"p"},"ChangeSets")," by creating a new section hierarchy whenever a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," is set with a Section with new props, or whenever a Section in the hierarchy updates its internal state when comparing the new hierarchy with the old hierarchy."),(0,r.mdx)("h2",{id:"what-is-a-sectiontree"},"What is a SectionTree?"),(0,r.mdx)("p",null,"Using the Sections framework begins with creating a ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/SectionTree.html"},"SectionTree"),"."),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," instances are responsible for:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Computing/recomputing changes whenever state & props values change."),(0,r.mdx)("li",{parentName:"ul"},"Communicating with a ",(0,r.mdx)("a",{parentName:"li",href:"pathname:///javadoc/com/facebook/litho/sections/SectionTree.Target.html"},"Target")," implementation that can update the UI (including telling the ",(0,r.mdx)("inlineCode",{parentName:"li"},"Target")," about new changes).")),(0,r.mdx)("p",null,"SectionTrees must be created with a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Target")," implementation. The ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/SectionTree.Target.html"},"Target")," interface is the API between ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," and the UI."),(0,r.mdx)("p",null,"After computing a ChangeSet from a section hierarchy, a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," instance will relay the changes to its ",(0,r.mdx)("inlineCode",{parentName:"p"},"Target"),". You can create a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Target")," for whatever custom UI you want, but the Sections framework has already implemented some ",(0,r.mdx)("inlineCode",{parentName:"p"},"Targets")," for you. ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/widget/SectionBinderTarget.html"},"SectionBinderTarget")," is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Target")," implementation that relays changes to a ",(0,r.mdx)("inlineCode",{parentName:"p"},"RecyclerBinder")," for rendering."),(0,r.mdx)("h2",{id:"updating-the-sectiontree"},"Updating the SectionTree"),(0,r.mdx)("p",null,"The framework can perform incremental and conditional updates on the structure of Sections whenever any props or state values change. The infrastructure also calculates the minimal operations it needs to perform on the existing hierarchy to update the list to reflect the new data."),(0,r.mdx)("p",null,"To update a section tree to reflect new props, create a section with the new prop values and call ",(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/SectionTree.html#setRoot-com.facebook.litho.sections.Section-"},"SectionTree#setRoot()"),". This is also how you set an initial root section on a tree since it's essentially diffing a new section hierarchy with an empty hierarchy."),(0,r.mdx)("p",null,"To update a section tree when a state value changes, perform a regular state update, as described in the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/codegen/state-for-specs"},"State for Specs")," page of the Litho documentation."),(0,r.mdx)("p",null,"You may notice that the ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateState()")," methods also have 'async' implementations, which are (",(0,r.mdx)("inlineCode",{parentName:"p"},"setRootAsync()")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateStateAsync()"),") respectively.  The ",(0,r.mdx)("inlineCode",{parentName:"p"},"*async()")," methods will ensure that the resulting ChangeSet calculation is performed on a background thread.  Otherwise, the resulting ChangeSet calculation will be done synchronously on whatever thread ",(0,r.mdx)("inlineCode",{parentName:"p"},"setRoot()")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateState()")," was called."),(0,r.mdx)("h2",{id:"computing-changesets"},"Computing ChangeSets"),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," instances compute changes in two steps: ",(0,r.mdx)("a",{parentName:"p",href:"#generating-trees"},"generating trees")," based on props/state values, then ",(0,r.mdx)("a",{parentName:"p",href:"#generating-a-changeset"},"generating a changeset")," by comparing two trees."),(0,r.mdx)("h3",{id:"generating-trees"},"Generating Trees"),(0,r.mdx)("p",null,"A tree is generated from a single root section by recursively calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"@OnCreateChildren")," on group section specs until it reaches the leaf sections, diff section specs.  As it visits a new section, ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," will:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Create a new ",(0,r.mdx)("inlineCode",{parentName:"li"},"SectionContext")," scoped to this new section."),(0,r.mdx)("li",{parentName:"ul"},"Check if there's a corresponding section in the current hierarchy, via ",(0,r.mdx)("a",{parentName:"li",href:"/docs/codegen/state-for-specs#keys-and-identifying-components"},"key"),") and transfer any state and service values over to the new section."),(0,r.mdx)("li",{parentName:"ul"},"Check if there's any pending state updates for the new section, via ",(0,r.mdx)("a",{parentName:"li",href:"/docs/codegen/state-for-specs#keys-and-identifying-components"},"key"),") and perform the updates if they exist."),(0,r.mdx)("li",{parentName:"ul"},"Create the new child sections by calling ",(0,r.mdx)("inlineCode",{parentName:"li"},"SectionLifecycle#createChildren")," then recursively visit those child sections.")),(0,r.mdx)("h3",{id:"generating-a-changeset"},"Generating a Changeset"),(0,r.mdx)("p",null,"After generating a new tree, ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," will recursively traverse the new tree and compare it against the current tree to generate a ",(0,r.mdx)("inlineCode",{parentName:"p"},"ChangeSet"),". This is where you call ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionLifecycle#generateChangeSet")," on Diff Sections. When traversing the new tree, the framework translates local indexes to global indexes as it merges all ",(0,r.mdx)("inlineCode",{parentName:"p"},"ChangeSet"),"s into a single ",(0,r.mdx)("inlineCode",{parentName:"p"},"ChangeSet")," for the whole hierarchy."),(0,r.mdx)("admonition",{type:"note"},(0,r.mdx)("p",{parentName:"admonition"},(0,r.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/sections/SectionContext.html"},"SectionContext")," is an object that is used to associate each ",(0,r.mdx)("inlineCode",{parentName:"p"},"Section")," instance in a hierarchy with its ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree"),". ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionContext")," instances are released and recreated every time a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," re-calculates its changeset (anytime props or state change). This means you should not rely on the ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionContext")," passed into your spec delegate methods to always be associated with a valid ",(0,r.mdx)("inlineCode",{parentName:"p"},"Section")," instance. As a general rule, a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionContext")," object is only valid between the ",(0,r.mdx)("inlineCode",{parentName:"p"},"@OnBindService")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"@OnUnbindService")," methods. You should not keep an instance of ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionContext")," alive outside this window.")),(0,r.mdx)("h3",{id:"sectiontree-and-the-recyclercollectioncomponent"},"SectionTree and the RecyclerCollectionComponent"),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"/docs/sections/recycler-collection-component"},"RecyclerCollectionComponent")," is a Litho component that creates and binds a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," to a ",(0,r.mdx)("inlineCode",{parentName:"p"},"Recycler")," behind the scenes to make it incredibly easy to use the Sections framework with Litho. ",(0,r.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," creates and holds onto a ",(0,r.mdx)("inlineCode",{parentName:"p"},"SectionTree")," instance as state and exposes a prop to accept new sections.  Updating the SectionTree when using ",(0,r.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," is as simple as updating the section prop passed into it."))}u.isMDXComponent=!0}}]);