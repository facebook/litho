"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5444],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>s,MDXProvider:()=>u,mdx:()=>y,useMDXComponents:()=>p,withMDXComponents:()=>d});var r=n(96540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},i.apply(this,arguments)}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),d=function(e){return function(t){var n=p(t.components);return r.createElement(e,i({},t,{components:n}))}},p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,m=d["".concat(a,".").concat(u)]||d[u]||f[u]||i;return n?r.createElement(m,c(c({ref:t},s),{},{components:n})):r.createElement(m,c({ref:t},s))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=h;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[m]="string"==typeof e?e:o,a[1]=c;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},17945:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>c,metadata:()=>s,toc:()=>p});var r=n(58168),o=n(98587),i=(n(96540),n(15680)),a=(n(52112),["components"]),c={id:"reconciliation",title:"Introduction"},l=void 0,s={unversionedId:"deep-dive/reconciliation",id:"deep-dive/reconciliation",title:"Introduction",description:"Reconciliation is an implementation detail in Litho\u2019s layout calculation process. Instead of recreating the entire layout tree for every update, reconciliation enables Litho to clone the",source:"@site/../docs/deep-dive/reconciliation.mdx",sourceDirName:"deep-dive",slug:"/deep-dive/reconciliation",permalink:"/docs/deep-dive/reconciliation",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/deep-dive/reconciliation.mdx",tags:[],version:"current",frontMatter:{id:"reconciliation",title:"Introduction"}},d={},p=[{value:"Tradeoffs",id:"tradeoffs",level:2}],u={toc:p},m="wrapper";function f(e){var t=e.components,n=(0,o.A)(e,a);return(0,i.mdx)(m,(0,r.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Reconciliation is an implementation detail in Litho\u2019s layout calculation process. Instead of recreating the entire layout tree for every update, reconciliation enables Litho to clone the\nunmodified subtrees and only recreate the subtree that has changed."),(0,i.mdx)("p",null,"When using Litho, the component hierarchy is determined by what is returned by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"OnCreateLayout")," method. On the next state or prop update, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"OnCreateLayout")," may return a different\ntree of components. Litho uses reconciliation to determine which components should be re-created and which can be re-used (read cloned)."),(0,i.mdx)("p",null,"In essence, this means Litho will not call (most) lifecycle methods of components which were unaffected by the update. Reconciliation enforces the requirement that component specs must\nbe immutable and should not rely on side-effects to achieve any desired behaviour."),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"As of December 2020, reconciliation is only implemented for state updates.")),(0,i.mdx)("h2",{id:"tradeoffs"},"Tradeoffs"),(0,i.mdx)("p",null,"It's important to remember that reconciliation is just an implementation detail; it's used for optimsation aimed at improving performance and doesn't affect the end result."),(0,i.mdx)("p",null,"To clariify, re-creation in this context means calling ",(0,i.mdx)("inlineCode",{parentName:"p"},"OnCreateLayout")," for the modified component, it doesn\u2019t mean Litho will unmount and remount them. Litho will only mount and unmount items that\nhave changed."),(0,i.mdx)("p",null,"In order to reconcile changes, Litho keeps the previous component hierarchy in memory. This increases memory usage and can potentially increase OOMs."))}f.isMDXComponent=!0}}]);