"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[547],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>l,MDXProvider:()=>d,mdx:()=>x,useMDXComponents:()=>c,withMDXComponents:()=>m});var o=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},s.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),m=function(e){return function(t){var n=c(t.components);return o.createElement(e,s({},t,{components:n}))}},c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,r=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=c(n),d=a,u=m["".concat(r,".").concat(d)]||m[d]||h[d]||s;return n?o.createElement(u,i(i({ref:t},l),{},{components:n})):o.createElement(u,i({ref:t},l))}));function x(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=g;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[u]="string"==typeof e?e:a,r[1]=i;for(var l=2;l<s;l++)r[l]=n[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},27520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>p,metadata:()=>m,toc:()=>d});var o=n(58168),a=n(98587),s=(n(96540),n(15680)),r=n(86025),i=["components"],p={id:"prop-matching",title:"Matching @Prop"},l=void 0,m={unversionedId:"testing/prop-matching",id:"testing/prop-matching",title:"Matching @Prop",description:"For help with setting up the Test environment, see the Getting Started page.",source:"@site/../docs/testing/prop-matching.mdx",sourceDirName:"testing",slug:"/testing/prop-matching",permalink:"/docs/testing/prop-matching",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/testing/prop-matching.mdx",tags:[],version:"current",frontMatter:{id:"prop-matching",title:"Matching @Prop"}},c={},d=[{value:"Complex Components",id:"complex-components",level:2},{value:"Testing Complex Components",id:"testing-complex-components",level:3},{value:"Props Matching with <code>@TestSpec</code>",id:"props-matching-with-testspec",level:2},{value:"Using <code>@TestSpec</code>",id:"using-testspec",level:3},{value:"Advanced Matchers",id:"advanced-matchers",level:3},{value:"Matching Matchers",id:"matching-matchers",level:3},{value:"A Note on Buck",id:"a-note-on-buck",level:2},{value:"TL;DR",id:"tldr",level:2}],u={toc:d},h="wrapper";function g(e){var t=e.components,n=(0,a.A)(e,i);return(0,s.mdx)(h,(0,o.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("admonition",{title:"Tips",type:"tip"},(0,s.mdx)("p",{parentName:"admonition"},"For help with setting up the Test environment, see the ",(0,s.mdx)("a",{parentName:"p",href:"/docs/testing/unit-testing"},"Getting Started")," page."),(0,s.mdx)("p",{parentName:"admonition"},"Before learning about ",(0,s.mdx)("inlineCode",{parentName:"p"},"@Prop")," matching, it's recommended you become familiar with ",(0,s.mdx)("a",{parentName:"p",href:"/docs/testing/subcomponent-testing"},"sub-component testing"),".")),(0,s.mdx)("p",null,"Within this page, you'll explore TestSpecs to test individual props of Components, even if you don't know all of them."),(0,s.mdx)("h2",{id:"complex-components"},"Complex Components"),(0,s.mdx)("p",null,"Composability is one of Litho's greatest strengths. It enables you to encapsulate your logic in small components and combine them effortlessly into larger ones. But, despite all good efforts, there is sometimes no clear dividing line and your component may grow beyond its original scope."),(0,s.mdx)("p",null,"Having complex components shouldn't prevent you from using them confidently. A set of powerful APIs give you the ability to test your components no matter what their size or complexity."),(0,s.mdx)("p",null,"Consider the following LayoutSpec 'ComplexComponentSpec':"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"@LayoutSpec\npublic class ComplexComponentSpec {\n  @OnCreateLayout\n  static Component onCreateLayout(\n      ComponentContext c,\n      @Prop StoryProps<ComplexAttachment> storyProps,\n      @Prop ImageRequest imageRequest,\n      @Prop DraweeController draweeController,\n      @Prop String title,\n      @Prop(resType = ResType.DIMEN_TEXT) int titleTextSize,\n      @Prop int visiblePhotoCount,\n      @Prop(optional = true) Artist favoriteArtist,\n      @Prop(optional = true) boolean shouldHavePuppies) {\n    return Row.create(c).build();\n  }\n}\n")),(0,s.mdx)("h3",{id:"testing-complex-components"},"Testing Complex Components"),(0,s.mdx)("p",null,"Within the props of the ",(0,s.mdx)("inlineCode",{parentName:"p"},"ComplexComponentSpec"),", there are a a lot of opaque objects that we may have trouble getting hold of for our tests. ",(0,s.mdx)("inlineCode",{parentName:"p"},"StoryProps")," might be something we obtain through some dependency injection mechanism. A ",(0,s.mdx)("inlineCode",{parentName:"p"},"DraweeController")," is an implementation detail we shouldn't have to worry about for ensuring that the component tree has the right shape. However, if you recall from the ",(0,s.mdx)("inlineCode",{parentName:"p"},"SubComponent.of")," API, it's necessary to specify all non-optional props for it to succeed."),(0,s.mdx)("img",{src:(0,r.default)("/images/complex-component-0.svg"),align:"right",width:"200px",className:"white-background"}),(0,s.mdx)("br",null),(0,s.mdx)("p",null,"To carry out the testing, you create a standard JUnit test suite and run it with a ",(0,s.mdx)("inlineCode",{parentName:"p"},"RobolectricTestRunner"),"-compatible implementation like ",(0,s.mdx)("inlineCode",{parentName:"p"},"LithoTestRunner"),"."),(0,s.mdx)("p",null,"As shown in the diagram to the right, assume that a ",(0,s.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent")," contains the ",(0,s.mdx)("inlineCode",{parentName:"p"},"ComplexComponent")," specified above.\nThe ",(0,s.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent")," contains the logic for populating our complex props which we want to verify, as shown in the following code:"),(0,s.mdx)("br",{clear:"right"}),(0,s.mdx)("br",null),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexSubComponent() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Two Brothers");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, legacySubComponent(SubComponent.of(\n          // ERROR: This fails at runtime as we haven\'t provided all\n          // required parameters.\n          ComplexComponent.create(c)\n            .title("Two Brothers")\n            .build()))));\n}\n\n')),(0,s.mdx)("p",null,"Sadly, this test fails with the following error message:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-bash"},"java.lang.IllegalStateException: The following props are not marked as optional and were not supplied: [storyProps, imageRequest, draweeController,titleTextSize, visiblePhotoCount]\n")),(0,s.mdx)("p",null,"If it's not possible to provide these props in your tests, or if you we don't want to test implementation details like the image loading controller, you could simply choose not to test any props at all and decide to verify only the presence of your component:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexSpecIsPresent() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Rixty Minutes");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, inspectedTypeIs(ComplexComponent.class)));\n}\n')),(0,s.mdx)("p",null,"While this type of testing is not perfect, it's better than nothing."),(0,s.mdx)("h2",{id:"props-matching-with-testspec"},"Props Matching with ",(0,s.mdx)("inlineCode",{parentName:"h2"},"@TestSpec")),(0,s.mdx)("p",null,"TestSpecs enable you to exactly match against those props that you want to test. Just as with LayoutSpecs and MountSpecs, TestSpecs make use of the powerful annotation processing mechanism Java offers and generate code for you."),(0,s.mdx)("p",null,"To start your testing project, create a new class and link it the original spec for which you want to generate the TestSpec:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"@TestSpec(ComplexComponentSpec.class)\npublic interface TestComplexComponentSpec {}\n")),(0,s.mdx)("p",null,"The above two lines are enough to generate a powerful 'matcher' that can be used in your tests."),(0,s.mdx)("p",null,"There are a few items of note:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"The class you reference in ",(0,s.mdx)("inlineCode",{parentName:"li"},"@TestSpec")," must be a LayoutSpec or MountSpec."),(0,s.mdx)("li",{parentName:"ul"},"You must link to the Spec and not the generated component, for example, ",(0,s.mdx)("inlineCode",{parentName:"li"},"ComplexComponentSpec.class")," not ",(0,s.mdx)("inlineCode",{parentName:"li"},"ComplexComponent.class"),"."),(0,s.mdx)("li",{parentName:"ul"},"In contrast to other specs, TestSpecs are generated from an interface, not a class."),(0,s.mdx)("li",{parentName:"ul"},"The interface must be empty: it cannot have any members."),(0,s.mdx)("li",{parentName:"ul"},"By convention, you prefix your TestSpec with ",(0,s.mdx)("inlineCode",{parentName:"li"},"Test"),", followed by the original spec name.")),(0,s.mdx)("p",null,"Now that the TestSpec is created, it's time to put it to use."),(0,s.mdx)("h3",{id:"using-testspec"},"Using ",(0,s.mdx)("inlineCode",{parentName:"h3"},"@TestSpec")),(0,s.mdx)("p",null,"Where normal components have a ",(0,s.mdx)("inlineCode",{parentName:"p"},"create")," function, test specs come with a ",(0,s.mdx)("inlineCode",{parentName:"p"},"matcher")," function.\nIt does take the same props as the underlying component but enable you to omit non-optional props, as shown in the following code:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecProps() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Two Brothers");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestComplexComponent.matcher(c)\n          .shouldHavePuppies(false)\n          .build()));\n}\n')),(0,s.mdx)("p",null,"This omission of puppies (.shouldHavePuppies(false)) couldn't possibly pass the test run. It will fail with the following 'helpful' error message:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-bash"},'java.lang.AssertionError:\nExpecting:\n <FeedItemComponent{0, 0 - 100, 100}\n  ComplexComponent{0, 0 - 100, 0}\n  Column{0, 0 - 100, 50}\n    FeedImageComponent{0, 0 - 100, 50}\n      RecyclerCollectionComponent{0, 0 - 100, 50}\n        Recycler{0, 0 - 100, 0}\n    TitleComponent{4, 46 - 16, 46}\n      Text{4, 46 - 16, 46 text="Some Name"}\n    ActionsComponent{60, 4 - 96, 40}\n      FavouriteButton{2, 2 - 34, 34 [clickable]}\n  FooterComponent{0, 50 - 100, 66}\n    Text{8, 8 - 92, 8 text="Two Brothers"}>\nto have:\n <sub component with <Sub-component of type <ComplexComponent> with prop <shouldHavePuppies> is <false> (doesn\'t match true)>>\n')),(0,s.mdx)("p",null,"From the error message, you can see a brief overview of the hierarchy you were matching against and the matcher that failed."),(0,s.mdx)("h3",{id:"advanced-matchers"},"Advanced Matchers"),(0,s.mdx)("p",null,"Instead of just matching against partial props, you can also provide 'hamcrest' matchers in any place that accepts concrete values. For props that take resource types, you can make use of all the same matchers you find in regular components:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},'@Test\npublic void testComplexTestSpecAdvancedProps() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<FeedItemComponent> component =\n      makeComponent("Rixty Minutes");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestComplexComponent.matcher(c)\n          // titleTextSizeDip, Sp etc. work too!\n          .titleTextSizeRes(R.dimen.notification_subtext_size)\n          .title(containsString("Minutes"))\n          .build()));\n}\n')),(0,s.mdx)("h3",{id:"matching-matchers"},"Matching Matchers"),(0,s.mdx)("p",null,"There is one type of prop that requires some special treatment: a Component."),(0,s.mdx)("p",null,"While you could just match against child components via normal equality (there is support for this), it is not particularly helpful. Rarely is it known what exact instance of a component is passed down to the props and you'll face many of the same problems discussed above: the props of the Component may not be known in full or perhaps you don't want to provide them all."),(0,s.mdx)("p",null,"The solution to these problems is to match matchers!"),(0,s.mdx)("p",null,"For any prop that takes a Component, the TestSpec generates a matcher that takes another matcher. This allows for ",(0,s.mdx)("strong",{parentName:"p"},"declarative matching against entire trees of components"),"."),(0,s.mdx)("p",null,"Continuing with the given example, suppose that the ",(0,s.mdx)("inlineCode",{parentName:"p"},"FeedItemComponent")," wraps the ",(0,s.mdx)("inlineCode",{parentName:"p"},"ComplexComponent")," in a ",(0,s.mdx)("inlineCode",{parentName:"p"},"Card"),", as shown in the following code:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecProps() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<FeedItemComponent> component = makeComponent("Ricksy Business");\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestCard.matcher(c)\n          .content(TestComplexComponent.matcher(c)\n            .title(endsWith("Business"))\n            .build())\n          .build()));\n}\n')),(0,s.mdx)("p",null,"Notice the ",(0,s.mdx)("inlineCode",{parentName:"p"},"TestCard")," used to declare the hierarchy; the ",(0,s.mdx)("inlineCode",{parentName:"p"},"litho-testing")," package comes with TestSpecs for all standard Litho widgets."),(0,s.mdx)("h2",{id:"a-note-on-buck"},"A Note on Buck"),(0,s.mdx)("p",null,"If you use Gradle, it should 'just work' and shouldn't require any additional setup."),(0,s.mdx)("p",null,"With Buck or Blaze/Bazel, you may need some additional configuration for the annotation processing step to work."),(0,s.mdx)("p",null,"In order to save your copy-pasting boilerplate all over your project, it is recommended to keep a rule definition like this in a well-known location (such as ",(0,s.mdx)("inlineCode",{parentName:"p"},"//tools/build_defs/android/litho_testspec.bzl"),"). You would obviously have to adjust the library paths to the corresponding targets in your code base."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-python"},'"""Provides macros for working with litho testspec."""\n\ndef litho_testspec(\n  name,\n  deps=None,\n  annotation_processors=None,\n  annotation_processor_deps=None,\n  **kwargs\n):\n  """Litho testspec."""\n  deps = deps or []\n  annotation_processors = annotation_processors or []\n  annotation_processor_deps = annotation_processor_deps or []\n\n  deps.extend(\n    [\n      "//java/com/facebook/litho:litho",\n      "//third-party/android/androidx:support-v4",\n      "//libraries/components/litho-testing/src/main/java/com/facebook/litho/testing:testing",\n      "//libraries/components/litho-testing/src/main/java/com/facebook/litho/testing/assertj:assertj",\n      "//third-party/java/jsr-305:jsr-305",\n      "//third-party/java/hamcrest:hamcrest",\n    ]\n  )\n\n  annotation_processor_deps.extend(\n    [\n      "//libraries/components/litho-processor/src/main/java/com/facebook/litho/specmodels/processor:processor-lib"\n    ]\n  )\n\n  annotation_processors.extend(\n    [\n      "com.facebook.litho.specmodels.processor.testing.ComponentsTestingProcessor",\n    ]\n  )\n\n  return android_library(\n    name,\n    deps=deps,\n    annotation_processors=annotation_processors,\n    annotation_processor_deps=annotation_processor_deps,\n    **kwargs\n  )\n')),(0,s.mdx)("p",null,"In the definitions for your test suite, you can then create a separate target for your test specs:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-python"},'load("//buck_imports:litho_testspec.bzl", "litho_testspec")\n\nlitho_testspec(\n  name = "testspecs",\n  srcs = glob(["*Spec.java"]),\n  deps = [\n    "//my/library/dependencies",\n    # ...\n  ],\n)\n\nrobolectric_test(\n  name = "test",\n  srcs = glob(["*Test.java*"]),\n  deps = [\n    ":testspecs",\n    # ...\n  ]\n)\n')),(0,s.mdx)("p",null,"This ensures that test specs are processed by the dedicated ",(0,s.mdx)("inlineCode",{parentName:"p"},"ComponentsTestingProcessor"),"."),(0,s.mdx)("h2",{id:"tldr"},"TL;DR"),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Step 1")," - Create a TestSpec for your LayoutSpec or MountSpec."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},"@TestSpec(MyLayoutSpec.class)\npublic interface TestMyLayoutSpec {}\n")),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Step 2")," - Use the generated test matcher in your suite."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java"},'@Test\npublic void testComplexTestSpecAdvancedProps() {\n  final ComponentContext c = mLithoTestRule.getContext();\n  final Component<MyWrapperComponent> component = ...;\n\n  assertThat(c, component)\n    .has(\n      subComponentWith(\n        c, TestMyLayout.matcher(c)\n          .titleTextSizeRes(R.dimen.notification_subtext_size)\n          .title(containsString("Minutes"))\n          .child(TestChildComponent.matcher(c).size(greaterThan(5)).build())\n          .build()));\n}\n')))}g.isMDXComponent=!0}}]);