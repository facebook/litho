"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1173],{15680:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>m,mdx:()=>g,useMDXComponents:()=>p,withMDXComponents:()=>d});var o=t(96540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),d=function(e){return function(n){var t=p(n.components);return o.createElement(e,i({},n,{components:t}))}},p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},f=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(t),m=a,u=d["".concat(r,".").concat(m)]||d[m]||h[m]||i;return t?o.createElement(u,s(s({ref:n},l),{},{components:t})):o.createElement(u,s({ref:n},l))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=f;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[u]="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=t[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}f.displayName="MDXCreateElement"},65935:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>g,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var o=t(58168),a=t(98587),i=(t(96540),t(15680)),r=t(86025),s=t(52112),c=["components"],l={id:"start",title:"Sections Basics"},d=void 0,p={unversionedId:"sections/start",id:"sections/start",title:"Sections Basics",description:"This page covers the older Java codegen-based Sections API. If creating a new list in Kotlin, refer to the Lazy Collection docs.",source:"@site/../docs/sections/start.mdx",sourceDirName:"sections",slug:"/sections/start",permalink:"/docs/sections/start",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/sections/start.mdx",tags:[],version:"current",frontMatter:{id:"start",title:"Sections Basics"},sidebar:"mainSidebar",previous:{title:"Making the UI Accessible",permalink:"/docs/codegen/accessibility-overview"},next:{title:"RecyclerCollectionComponent",permalink:"/docs/sections/recycler-collection-component"}},m={},u=[{value:"Introduction",id:"introduction",level:2},{value:"List building blocks",id:"list-building-blocks",level:2},{value:"RecyclerCollectionComponent",id:"recyclercollectioncomponent",level:3},{value:"DiffSection",id:"diffsection",level:3},{value:"SingleComponentSection",id:"singlecomponentsection",level:4},{value:"DataDiffSection",id:"datadiffsection",level:4},{value:"GroupSection",id:"groupsection",level:3},{value:"Putting all the pieces together",id:"putting-all-the-pieces-together",level:2},{value:"Further reading",id:"further-reading",level:2}],h={toc:u},f="wrapper";function g(e){var n=e.components,t=(0,a.A)(e,c);return(0,i.mdx)(f,(0,o.A)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("admonition",{type:"caution"},(0,i.mdx)("p",{parentName:"admonition"},"This page covers the older Java codegen-based Sections API. If creating a new list in Kotlin, refer to the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/kotlin/lazycollections/"},"Lazy Collection docs"),".")),(0,i.mdx)("h2",{id:"introduction"},"Introduction"),(0,i.mdx)("p",null,"The Sections API provides a declarative, composable, and thread-safe API for writing highly optimised List screens. It addresses issues experienced when writing complex Lists, such as maintaining many view types, handling multiple data sources, and composing Lists together."),(0,i.mdx)("p",null,"Litho Components are used for various aspects of the UI. Sections are a way of composing data into a list of Litho Components or Views."),(0,i.mdx)("p",null,"If the screen is visualized as being a tree of components, the nodes for the root of the tree and the subtrees are Sections, while the leaves are Litho Components that represent individual items that will be displayed on screen. The following diagram shows the relationship between Sections and Litho components."),(0,i.mdx)("img",{src:(0,r.default)("/images/sections-intro.png"),width:"800px"}),(0,i.mdx)("p",null,"Sections use the same hierarchical declarative data model as Components. Under the hood, Sections transparently handle processes such as calculating minimal sets of changes for data updates and granular UI refreshes. As part of Litho, the Sections API shares the same main concepts, such as annotation-based code generation, event handling, props, and state updates. Sections functionality is built on top of ",(0,i.mdx)("a",{parentName:"p",href:"https://developer.android.com/guide/topics/ui/layout/recyclerview"},"Android's RecyclerView"),"."),(0,i.mdx)("h2",{id:"list-building-blocks"},"List building blocks"),(0,i.mdx)("p",null,"This section details the parts necessary to build a list: a ",(0,i.mdx)("a",{parentName:"p",href:"#recyclercollectioncomponent"},"RecyclerCollectionComponent")," for layout, which sets several ",(0,i.mdx)("inlineCode",{parentName:"p"},"DiffSection"),"s that are either ",(0,i.mdx)("a",{parentName:"p",href:"#singlecomponentsection"},"SingleComponentSection")," or ",(0,i.mdx)("a",{parentName:"p",href:"#datadiffsection"},"DataDiffSection"),", all contained inside ",(0,i.mdx)("a",{parentName:"p",href:"#groupsection"},"GroupSection")," hierarchies."),(0,i.mdx)("p",null,"As preparation, the following 10-minute video 'Litho Lessons: Diffing in Sections' covers the basics of how diffing operates."),(0,i.mdx)("div",{align:"center"},(0,i.mdx)("iframe",{"padding-top":"10px",width:"560",height:"315",src:"https://www.youtube-nocookie.com/embed/-Ahskig2Lw0",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})),(0,i.mdx)("h3",{id:"recyclercollectioncomponent"},"RecyclerCollectionComponent"),(0,i.mdx)("p",null,"As with any other component, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent")," can be used by building it and adding it as a child in the layout:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"RecyclerCollectionComponent.create(c)\n    .section(createGroupSection())\n    .build();\n")),(0,i.mdx)("p",null,"For now, this is all that needs to be known about adding Sections to a layout.  For advanced use cases, such as snapping and horizontal Lists, see the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/sections/recycler-collection-component"},"RecyclerCollectionComponent")," page."),(0,i.mdx)("h3",{id:"diffsection"},"DiffSection"),(0,i.mdx)("p",null,"Most Lists are composed of groups of homogeneous items interleaved with one-off items: picture a list of contacts sorted alphabetically and separated by headers indicating the first letter of the contact's name."),(0,i.mdx)("p",null,"Following this model, the Sections API ships two ",(0,i.mdx)("inlineCode",{parentName:"p"},"DiffSectionSpec")," implementations that can be combined to represent the structure of nearly any surface: ",(0,i.mdx)("a",{parentName:"p",href:"#singlecomponentsection"},"SingleComponentSection")," and ",(0,i.mdx)("a",{parentName:"p",href:"#datadiffsection"},"DataDiffSection"),"."),(0,i.mdx)("h4",{id:"singlecomponentsection"},"SingleComponentSection"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("inlineCode",{parentName:"p"},"SingleComponentSection")," is used to represent a ",(0,i.mdx)("strong",{parentName:"p"},"one-off row")," in a complex list. As the name suggests, Section can be used to render a single Component, which is passed to this Section as its only prop."),(0,i.mdx)("p",null,"One of the typical use cases of a ",(0,i.mdx)("inlineCode",{parentName:"p"},"SingleComponentSection")," is to add a loading spinner at the end of a list:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"SingleComponentSection.create(c)\n    .component(Progress.create(c).build())\n    .build();\n")),(0,i.mdx)("p",null,"Or a header for your data:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'SingleComponentSection.create(c)\n    .component(Text.create(c).text("Friends").build())\n    .build();\n')),(0,i.mdx)("h4",{id:"datadiffsection"},"DataDiffSection"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," is used to represent a ",(0,i.mdx)("strong",{parentName:"p"},"homogeneous list of immutable data"),".\nThe minimal information that must be passed to a ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," is the list of items that it needs to render and a callback for rendering each item in this list."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"DataDiffSection.<MyModel>create(c)\n    .data(ImmutableList.of(new MyModel(1), new MyModel(2), new MyModel(3)))\n    .renderEventHandler(MyGroupSection.onRenderEdge(c));\n")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," is designed to efficiently render the parts of a surface that handle large flows of data. When an item at a certain position needs to be displayed on screen, the framework checks whether the model received in the new list of data changed since the last time it was rendered."),(0,i.mdx)("p",null,"If the data changed for the item in that position, the framework would dispatch a ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," for that item, and the ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," will use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RenderEvent")," handler passed as a prop to create a Component for that item and display it."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@OnEvent(RenderEvent.class)\nstatic RenderInfo onRenderEdge(\n    SectionContext c,\n    @FromEvent MyModel model) {\n    return ComponentRenderInfo.create()\n        .component(MyModelItemComponent.create(c).item(model).build())\n        .build();\n}\n")),(0,i.mdx)("p",null,"By default, ",(0,i.mdx)("inlineCode",{parentName:"p"},"DataDiffSection")," will detect data changes by checking instance equality and subsequently calling ",(0,i.mdx)("inlineCode",{parentName:"p"},"equals")," on the objects in the data list."),(0,i.mdx)("admonition",{type:"tip"},(0,i.mdx)("p",{parentName:"admonition"},"For a deep dive into how to build performant and accurate diffing, including diffing for classes where ",(0,i.mdx)("inlineCode",{parentName:"p"},"equals")," is not overridden, see the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/sections/best-practices"},"Best Practices and Performance")," documentation.")),(0,i.mdx)("h3",{id:"groupsection"},"GroupSection"),(0,i.mdx)("p",null,"A ",(0,i.mdx)("inlineCode",{parentName:"p"},"GroupSectionSpec")," is used to ",(0,i.mdx)("strong",{parentName:"p"},"structure your Sections into a hierarchy"),", each one responsible for rendering its own chunk of data."),(0,i.mdx)("p",null,"Group section specs are classes annotated with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@GroupSectionSpec"),". Implementing a ",(0,i.mdx)("inlineCode",{parentName:"p"},"GroupSectionSpec")," is very simple: just write one method annotated with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateChildren"),". This method returns a tree of Sections that will have root in this ",(0,i.mdx)("inlineCode",{parentName:"p"},"GroupSectionSpec"),"."),(0,i.mdx)("p",null,"The following code shows how to declare a simple List that contains a header followed by a list of ",(0,i.mdx)("inlineCode",{parentName:"p"},"String")," items:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@GroupSectionSpec\nclass SimpleListSectionSpec {\n\n  @OnCreateChildren\n  static Children onCreateChildren(\n      SectionContext c,\n      @Prop String headerTitle,\n      @Prop List<String> data) {\n    return Children.create()\n        .child(\n            SingleComponentSection.create(c)\n                .component(\n                    Text.create(c)\n                        .text(headerTitle)\n                        .build()))\n        .child(\n            DataDiffSection.<String>create(c)\n                .data(data)\n                .renderEventHandler(SimpleListSection.onRender(c)))\n        .build();\n  }\n\n  @OnEvent(RenderEvent.class)\n  static RenderInfo onRender(\n      SectionContext c,\n      @FromEvent String model) {\n    return ComponentRenderInfo.create()\n        .component(\n            Text.create(c)\n                .text(model)\n                .build())\n        .build();\n    }\n}\n")),(0,i.mdx)("h2",{id:"putting-all-the-pieces-together"},"Putting all the pieces together"),(0,i.mdx)("p",null,"Imagine a surface that has multiple sub-sections consisting of a header and a list of Strings. An example of this is a list of contacts grouped alphabetically, delimited by headers showing the first letter of the name. This could be achieved easily by creating a ",(0,i.mdx)("inlineCode",{parentName:"p"},"GroupSectionSpec")," that has a ",(0,i.mdx)("inlineCode",{parentName:"p"},"SimpleListSection")," child for every letter, as described in the following code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@GroupSectionSpec\nclass ContactsSectionSpec {\n\n  @OnCreateChildren\n  static Children onCreateChildren(\n      SectionContext c,\n      @Prop List<String> data) {\n\n    final Children.Builder builder = Children.create();\n\n    for(char firstLetter = 'A'; firstLetter <= 'Z'; firstLetter++) {\n        builder.child(\n            SimpleListSection.create(c)\n                .key(String.valueOf(firstLetter))\n                .headerTitle(String.valueOf(firstLetter))\n                .data(getItemsForLetter(firstLetter, data)));\n    }\n\n    return build.build();\n  }\n}\n")),(0,i.mdx)("p",null,"The following image is a representation of the tree of Sections that has its root in ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContactsSectionSpec"),". Each node in the tree is a Section, and the leaves are Components that can be rendered on screen. Each one of the sections in the tree acts as a data source.  Its purpose is to describe what data it needs and how that data should be rendered."),(0,i.mdx)("img",{src:(0,r.default)("/images/group-section-spec.png"),width:"800"}),(0,i.mdx)("p",null,"The Sections hierarchy becomes a data source for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"RecyclerCollectionComponent"),". To create each ",(0,i.mdx)("inlineCode",{parentName:"p"},"SimpleListSection"),", it's only necessary to pass the data that the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ContactsSection")," will use, as shown in the following code."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\nstatic Component onCreateLayout(\n    final ComponentContext c) {\n  return RecyclerCollectionComponent.create(c)\n    .section(\n        ContactsSection.create(new SectionContext(c))\n            .dataModel(ImmutableList.of("Andy", "Aziz", "Aditya", "Nico", "Sergey"))\n            .build())\n    .build();\n}\n')),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"The complexity of handling operations on a list, such as inserts or removes, is hidden away and handled by the infrastructure.")),(0,i.mdx)("h2",{id:"further-reading"},"Further reading"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/sections/best-practices"},"Best Practices and Performance")," (start here)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/sections/recycler-collection-component"},"Adding and Adapting RecyclerCollection to your App")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/sections/services"},"Advanced Topic: Granular Dependency Injection")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/sections/working-ranges"},"Advanced Topic: Prefetch and Pagination"))),(0,i.mdx)(s.FbInternalOnly,{mdxType:"FbInternalOnly"},"If you need assistance, consult the internal Wiki page [Debugging Litho Sections Surfaces with the Flipper Sections Plugin](https://fburl.com/wiki/sr02b53q)."))}g.isMDXComponent=!0}}]);