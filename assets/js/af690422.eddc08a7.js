"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6469],{15680:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>m});var a=t(96540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),m=function(e){return function(n){var t=d(n.components);return a.createElement(e,o({},n,{components:t}))}},d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},x=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=d(t),c=i,u=m["".concat(r,".").concat(c)]||m[c]||h[c]||o;return t?a.createElement(u,s(s({ref:n},l),{},{components:t})):a.createElement(u,s({ref:n},l))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=x;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}x.displayName="MDXCreateElement"},36744:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var a=t(58168),i=t(98587),o=(t(96540),t(15680)),r=(t(86025),["components"]),s={id:"custom-layout",title:"Manual Measurement"},p=void 0,l={unversionedId:"custom-layout",id:"custom-layout",title:"Manual Measurement",description:"Litho relies on Yoga, a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic.",source:"@site/../docs/custom-layout.md",sourceDirName:".",slug:"/custom-layout",permalink:"/docs/custom-layout",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/custom-layout.md",tags:[],version:"current",frontMatter:{id:"custom-layout",title:"Manual Measurement"}},m={},d=[{value:"Use Cases",id:"use-cases",level:2},{value:"Size Specs",id:"size-specs",level:2},{value:"Measuring a Component",id:"measuring-a-component",level:2},{value:"SizeSpec Information During Layout",id:"sizespec-information-during-layout",level:2},{value:"Kotlin Integration",id:"kotlin-integration",level:2}],c={toc:d},u="wrapper";function h(e){var n=e.components,t=(0,i.A)(e,r);return(0,o.mdx)(u,(0,a.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Litho relies on ",(0,o.mdx)("a",{parentName:"p",href:"https://yogalayout.dev/docs/"},"Yoga"),", a powerful layout engine that can create very complex UIs for layout calculations.  However, there are few exceptions where Yoga is not sufficient and you may need to implement your own measuring and layout logic."),(0,o.mdx)("p",null,"Litho provides a manual component measurement API for determining component sizes during layout creation, which enables Developers to implement dynamic logic based on component sizes."),(0,o.mdx)("admonition",{title:"IMPORTANT",type:"caution"},(0,o.mdx)("p",{parentName:"admonition"}," This API comes with a ",(0,o.mdx)("strong",{parentName:"p"},"non-negligible")," performance overhead.\nLitho is built to optimise when a measure occurs for any component. Measuring a component with this API ends up performing additional measurements to the ones intrinsic to Litho's lifecycle. Measurement can become a heavy operation, especially with more complex layouts, so be sure to only utilize this API when absolutely necessary.")),(0,o.mdx)("h2",{id:"use-cases"},"Use Cases"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"A component layout tree depends on its own and/or children's size.")," For example, perhaps a component layout should use a child only if it fits within its size constraints. If the child doesn't fit, the layout should instead use another child as a fallback.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"Children of a container must be absolutely positioned manually based on their/parent size.")," Yoga can absolutely position children in a parent. However, the position itself might depend on the child sizes after being measured using the parent size constraints. Margins or paddings need to be manually considered if required.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("strong",{parentName:"p"},"This API should only be used during layout creation.")," Using the API elsewhere may cause unintended behaviour."))),(0,o.mdx)("h2",{id:"size-specs"},"Size Specs"),(0,o.mdx)("p",null,"Before diving into the API, it's recommended that you familiarise yourself with how the ",(0,o.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int)"},"onMeasure")," function works in a regular Android ",(0,o.mdx)("inlineCode",{parentName:"p"},"View"),".  Also,  what a ",(0,o.mdx)("a",{parentName:"p",href:"https://developer.android.com/reference/android/view/View.MeasureSpec.html"},"MeasureSpec")," is, since Litho uses an analogous concept called ",(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/SizeSpec.html"},"SizeSpec"),"."),(0,o.mdx)("p",null,"Similar to the Android ",(0,o.mdx)("inlineCode",{parentName:"p"},"MeasureSpec")," equivalent, Litho's ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec")," is composed of a size and a mode. The possible modes, same as for ",(0,o.mdx)("inlineCode",{parentName:"p"},"MeasureSpec"),", are: ",(0,o.mdx)("inlineCode",{parentName:"p"},"UNSPECIFIED"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"EXACTLY"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"AT_MOST"),"."),(0,o.mdx)("h2",{id:"measuring-a-component"},"Measuring a Component"),(0,o.mdx)("p",null,"A component can be measured in isolation for a given ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),". A ",(0,o.mdx)("inlineCode",{parentName:"p"},"Size")," object, passed as an argument, will be populated with the resulting size."),(0,o.mdx)("p",null,"In the following example, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured with unspecified ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),", implying a single line of text indefinitely long."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java"},"final Component<Text> textComponent = Text.create(c)\n    .textSizeSp(16)\n    .text(\u201cSome text to measure.\u201d)\n    .build();\n\nfinal Size outputSize = new Size();\ntextComponent.measure(\n    c,\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n    outputSize);\n\nfinal int textComponentWidth = outputSize.width;\nfinal int textComponentHeight = outputSize.height;\n")),(0,o.mdx)("h2",{id:"sizespec-information-during-layout"},"SizeSpec Information During Layout"),(0,o.mdx)("p",null,"During layout creation, the API can provide information about the ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec"),"s with which the component is going to be measured. To access this information, the ",(0,o.mdx)("a",{parentName:"p",href:"pathname:///javadoc/com/facebook/litho/annotations/OnCreateLayoutWithSizeSpec.html"},"@OnCreateLayoutWithSizeSpec")," annotation needs to be used instead of ",(0,o.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayout"),". The arguments of the annotated method, besides the standard ",(0,o.mdx)("inlineCode",{parentName:"p"},"ComponentContext"),", are two more integers representing the width spec and the height spec."),(0,o.mdx)("p",null,"Similar to Android's ",(0,o.mdx)("inlineCode",{parentName:"p"},"MeasureSpec"),", you can resolve the exact size of a width or height spec integers by using ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec.getSize(widthSpec)"),", and the mode with ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec.getMode(widthSpec)"),"."),(0,o.mdx)("p",null,"In the following example, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"Text")," component is measured to check if the given text fits in the available space. An ",(0,o.mdx)("inlineCode",{parentName:"p"},"Image")," component is otherwise used."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/documentation/LongTextReplacerComponentSpec.java start=start_example end=end_example",file:"sample/src/main/java/com/facebook/samples/litho/java/documentation/LongTextReplacerComponentSpec.java",start:"start_example",end:"end_example"},'@LayoutSpec\nclass LongTextReplacerComponentSpec {\n\n  @OnCreateLayoutWithSizeSpec\n  static Component onCreateLayoutWithSizeSpec(ComponentContext c, int widthSpec, int heightSpec) {\n\n    final Component textComponent =\n        Text.create(c).textSizeSp(16).text("Some text to measure.").build();\n\n    // UNSPECIFIED sizeSpecs will measure the text as being one line only,\n    // having unlimited width.\n    final Size textOutputSize = new Size();\n    textComponent.measure(\n        c,\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n        textOutputSize);\n\n    // Small component to use in case textComponent doesn\u2019t fit within\n    // the current layout.\n    final Component imageComponent = Image.create(c).drawableRes(R.drawable.ic_launcher).build();\n\n    // Assuming SizeSpec.getMode(widthSpec) == EXACTLY or AT_MOST.\n    final int layoutWidth = SizeSpec.getSize(widthSpec);\n    final boolean textFits = (textOutputSize.width <= layoutWidth);\n\n    return textFits ? textComponent : imageComponent;\n  }\n}\n')),(0,o.mdx)("h2",{id:"kotlin-integration"},"Kotlin Integration"),(0,o.mdx)("p",null,"Kotlin equivalent of ",(0,o.mdx)("inlineCode",{parentName:"p"},"@OnCreateLayoutWithSizeSpec")," is called ",(0,o.mdx)("inlineCode",{parentName:"p"},"RenderWithConstraints"),". ",(0,o.mdx)("inlineCode",{parentName:"p"},"RenderWithConstraints")," is a Component that defines its own content according to the available space, based on the incoming ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeConstraints"),". It can be used in situations when a different content needs to be displayed depending on the available space."),(0,o.mdx)("p",null,"Below, there is an example that uses ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeConstraints")," provided by ",(0,o.mdx)("inlineCode",{parentName:"p"},"RenderWithConstraints"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/renderwithconstraints/RenderWithConstraintsKComponent.kt start=start_renderwithconstraints_example end=end_renderwithconstraints_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/renderwithconstraints/RenderWithConstraintsKComponent.kt",start:"start_renderwithconstraints_example",end:"end_renderwithconstraints_example"},'RenderWithConstraints(style = Style.width(width.value.dp)) { sizeConstraints ->\n  val textComponent = Text(textSize = 16.sp, text = "Some text to measure")\n\n  val textOutputSize = Size()\n\n  textComponent.measure(\n      context,\n      SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n      SizeSpec.makeSizeSpec(0, UNSPECIFIED),\n      textOutputSize)\n\n  // Small component to use in case textComponent doesn\u2019t fit within\n  // the current layout.\n  val imageComponent = Image(drawable = drawableRes(R.drawable.ic_launcher))\n\n  // Assuming sizeConstraints.hasBoundedWidth == true\n  val doesTextFit = textOutputSize.width <= sizeConstraints.maxWidth\n\n  if (doesTextFit) textComponent else imageComponent\n})\n')),(0,o.mdx)("admonition",{type:"note"},(0,o.mdx)("p",{parentName:"admonition"},"In Kotlin the ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeSpec")," has been replaced with ",(0,o.mdx)("inlineCode",{parentName:"p"},"SizeConstraints"),". It's an object that provides the minimum and maximum width and height available for a Component. SizeConstraints are provided by parent Component to a child component. A child Component should define its size within those constraints.")))}h.isMDXComponent=!0}}]);