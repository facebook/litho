"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4304],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>s,MDXProvider:()=>m,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>c});var a=n(96540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){return function(t){var n=p(t.components);return a.createElement(e,i({},t,{components:n}))}},p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},x=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),c=p(n),m=o,u=c["".concat(r,".").concat(m)]||c[m]||h[m]||i;return n?a.createElement(u,l(l({ref:t},s),{},{components:n})):a.createElement(u,l({ref:t},s))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=x;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[u]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}x.displayName="MDXCreateElement"},84632:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=n(58168),o=n(98587),i=(n(96540),n(15680)),r=["components"],l={id:"state-for-specs",title:"State in Specs"},d=void 0,s={unversionedId:"codegen/state-for-specs",id:"codegen/state-for-specs",title:"State in Specs",description:"This page introduces the concept of state in a component written using the Java Spec API, namely a @LayoutSpec or @MountSpec.",source:"@site/../docs/codegen/state-for-specs.md",sourceDirName:"codegen",slug:"/codegen/state-for-specs",permalink:"/docs/codegen/state-for-specs",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/codegen/state-for-specs.md",tags:[],version:"current",frontMatter:{id:"state-for-specs",title:"State in Specs"},sidebar:"mainSidebar",previous:{title:"TreeProps",permalink:"/docs/codegen/passing-data-to-components/treeprops"},next:{title:"Events for Specs",permalink:"/docs/codegen/events-for-specs"}},c={},p=[{value:"Adding Local State to a Component",id:"adding-local-state-to-a-component",level:2},{value:"1. Replace the <code>counter</code> prop declaration with a state declaration",id:"1-replace-the-counter-prop-declaration-with-a-state-declaration",level:3},{value:"2. Set an initial value for the <code>count</code> state",id:"2-set-an-initial-value-for-the-count-state",level:3},{value:"3. Use the state value",id:"3-use-the-state-value",level:3},{value:"Updating State",id:"updating-state",level:2},{value:"1. Set click handlers on the buttons",id:"1-set-click-handlers-on-the-buttons",level:3},{value:"2. Update the state value in the click handlers",id:"2-update-the-state-value-in-the-click-handlers",level:3},{value:"State API reference and considerations",id:"state-api-reference-and-considerations",level:2},{value:"Data Immutability",id:"data-immutability",level:3},{value:"Component identity",id:"component-identity",level:3},{value:"Initialising State values",id:"initialising-state-values",level:3},{value:"Updating State values",id:"updating-state-values",level:3}],m={toc:p},u="wrapper";function h(e){var t=e.components,n=(0,o.A)(e,r);return(0,i.mdx)(u,(0,a.A)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("admonition",{type:"caution"},(0,i.mdx)("p",{parentName:"admonition"},"This page introduces the concept of state in a component written using the Java Spec API, namely a ",(0,i.mdx)("inlineCode",{parentName:"p"},"@LayoutSpec")," or ",(0,i.mdx)("inlineCode",{parentName:"p"},"@MountSpec"),"."),(0,i.mdx)("p",{parentName:"admonition"},"If you aren't using the Spec API, refer to the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/hooks-intro"},"Introduction to Hooks")," page.")),(0,i.mdx)("p",null,"A component can have two types of data:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Props")," - passed down from the parent and cannot change during a component's lifecycle."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"State")," - state data is encapsulated and managed within the component and is transparent to the parent.")),(0,i.mdx)("p",null,"This page uses the example of a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Counter")," component, in which the user can click a button to increase or decrease a value."),(0,i.mdx)("p",null,"The following example illustrates how to use State to make the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Counter")," component reusable and encapsulated; it provides an overview of adding state to a component."),(0,i.mdx)("p",null,"Start by encapsulating how the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Counter")," looks:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @Prop int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+"))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-"))\n        .build();\n  }\n}\n')),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"Counter")," component is missing a crucial feature: interacting with the buttons to update the count value."),(0,i.mdx)("p",null,"Ideally, this component should encapsulate all this behaviour in its internal implementation, which would mean writing it once then reusing it anywhere the counter is needed:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"final CounterComponent counter = CounterComponent.create().build();\n")),(0,i.mdx)("p",null,"To implement this, add 'state' to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Counter")," component."),(0,i.mdx)("h2",{id:"adding-local-state-to-a-component"},"Adding Local State to a Component"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"counter")," can be changed from prop to state in three steps:"),(0,i.mdx)("h3",{id:"1-replace-the-counter-prop-declaration-with-a-state-declaration"},"1. Replace the ",(0,i.mdx)("inlineCode",{parentName:"h3"},"counter")," prop declaration with a state declaration"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        //...\n        .build();\n  }\n}\n")),(0,i.mdx)("h3",{id:"2-set-an-initial-value-for-the-count-state"},"2. Set an initial value for the ",(0,i.mdx)("inlineCode",{parentName:"h3"},"count")," state"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"@OnCreateInitialState\nstatic void onCreateInitialState(ComponentContext c, StateValue<Integer> count) {\n  count.set(1);\n}\n")),(0,i.mdx)("h3",{id:"3-use-the-state-value"},"3. Use the state value"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+"))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-"))\n        .build();\n  }\n')),(0,i.mdx)("h2",{id:"updating-state"},"Updating State"),(0,i.mdx)("p",null,"Next, make the Counter component update the count value when the increase or decrease buttons are clicked, in two steps:"),(0,i.mdx)("h3",{id:"1-set-click-handlers-on-the-buttons"},"1. Set click handlers on the buttons"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'@OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(Text.create(c).text("+").clickHandler(CounterComponent.onClickIncrease(c)))\n        .child(Text.create(c).text("" + count))\n        .child(Text.create(c).text("-").clickHandler(CounterComponent.onClickDecrease(c)))\n        .build();\n  }\n\n@OnEvent(ClickEvent.class)\nstatic void onClickIncrease(ComponentContext c) {}\n\n@OnEvent(ClickEvent.class)\nstatic void onClickDecrease(ComponentContext c) {}\n')),(0,i.mdx)("h3",{id:"2-update-the-state-value-in-the-click-handlers"},"2. Update the state value in the click handlers"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/identity/CounterComponentSpec.java start=start_counter end=end_counter",file:"sample/src/main/java/com/facebook/samples/litho/java/identity/CounterComponentSpec.java",start:"start_counter",end:"end_counter"},'@LayoutSpec\nclass CounterComponentSpec {\n\n  @OnCreateInitialState\n  static void onCreateInitialState(ComponentContext c, StateValue<Integer> count) {\n    count.set(1);\n  }\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c, @State int count) {\n    return Row.create(c)\n        .child(\n            Text.create(c)\n                .text(" INCREASE ")\n                .textSizeSp(16)\n                .paddingPx(YogaEdge.END, 8)\n                .clickHandler(CounterComponent.onClickIncrease(c)))\n        .child(Text.create(c).textSizeSp(16).text("" + count))\n        .child(\n            Text.create(c)\n                .text(" DECREASE ")\n                .textSizeSp(16)\n                .paddingPx(YogaEdge.START, 8)\n                .clickHandler(CounterComponent.onClickDecrease(c)))\n        .build();\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickIncrease(ComponentContext c) {\n    CounterComponent.increase(c);\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onClickDecrease(ComponentContext c) {\n    CounterComponent.decrease(c);\n  }\n\n  @OnUpdateState\n  static void increase(StateValue<Integer> count) {\n    count.set(count.get() + 1);\n  }\n\n  @OnUpdateState\n  static void decrease(StateValue<Integer> count) {\n    count.set(count.get() - 1);\n  }\n}\n')),(0,i.mdx)("h2",{id:"state-api-reference-and-considerations"},"State API reference and considerations"),(0,i.mdx)("h3",{id:"data-immutability"},"Data Immutability"),(0,i.mdx)("p",null,"Due to background layout, state can be accessed anytime by multiple threads. To ensure thread safety, state objects should be immutable (if for some rare reason this is not possible, then at least thread safe). The simplest solution is to express state in terms of primitives since primitives are, by definition, immutable."),(0,i.mdx)("h3",{id:"component-identity"},"Component identity"),(0,i.mdx)("p",null,"Litho uses keys to keep track of component identity between layout changes and correctly identify a component as the target of a state update. For more information on how the component identity functions, see the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/coordinate-state-actions/keys-and-identity"},"Keys and Component Identity")," page."),(0,i.mdx)("h3",{id:"initialising-state-values"},"Initialising State values"),(0,i.mdx)("p",null,"State initialisation is guaranteed to happen once and only once for a component based on its identity, even if there are multiple threads attempting to calculate the layout for the same component in parallel."),(0,i.mdx)("p",null,"In the Java API, the method annotated with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," is guaranteed to be called just once during a component's lifecycle."),(0,i.mdx)("p",null,"This is an important consideration that should be kept in mind when using prop values to initialize state. Passing new props to a component does not call the initializer again; a state value can only be updated after it was initialized by using the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/codegen/state-for-specs#updating-state"},"state update APIs"),"."),(0,i.mdx)("p",null,"In the Java API, to set an initial value for a state, write a method annotated with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," in the spec."),(0,i.mdx)("p",null,"The following are points to keep in mind when writing an ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnCreateInitialState")," method:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The first parameter must be of type ",(0,i.mdx)("inlineCode",{parentName:"li"},"ComponentContext"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"@Prop")," parameters are allowed, but ",(0,i.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," methods are not called again if the props change."),(0,i.mdx)("li",{parentName:"ul"},"All other parameters must have a corresponding parameter annotated with ",(0,i.mdx)("inlineCode",{parentName:"li"},"@State")," in the other lifecycle methods, and their type must be a ",(0,i.mdx)("a",{parentName:"li",href:"pathname:///javadoc/com/facebook/litho/StateValue.html"},"StateValue")," that is parameterized with the type of the matching ",(0,i.mdx)("inlineCode",{parentName:"li"},"@State")," element."),(0,i.mdx)("li",{parentName:"ul"},"Initializing a state value is not mandatory and implementing an ",(0,i.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," method can be entirely skipped. If a state value is not explicitly initialised, the initial state is assigned the default value of its inferred type. For example, ",(0,i.mdx)("inlineCode",{parentName:"li"},"0")," for integer state, ",(0,i.mdx)("inlineCode",{parentName:"li"},"false")," for Boolean state or ",(0,i.mdx)("inlineCode",{parentName:"li"},"null")," for Objects."),(0,i.mdx)("li",{parentName:"ul"},"There should never be a need for a Developer to call the ",(0,i.mdx)("inlineCode",{parentName:"li"},"@OnCreateInitialState")," method themselves.")),(0,i.mdx)("h3",{id:"updating-state-values"},"Updating State values"),(0,i.mdx)("p",null,"Every state update triggers a new layout calculation for its ",(0,i.mdx)("inlineCode",{parentName:"p"},"ComponentTree"),". Passing new props to a Litho component and updating the state are implemented in the same way in Litho, so there is no performance difference. To understand when you a component should be updated using new props or updating state, see the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/best-practices/props-vs-state"},"Props vs. State")," page."),(0,i.mdx)("p",null,"However, Litho implements a feature called reconciliation, which attempts to detect what part of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ComponentTree")," is affected by that state update and reuse the layout for the nodes that don't need to change.\nState updates can be performed synchronously on the same thread that they were triggered from, or asynchronously from Litho's background thread."),(0,i.mdx)("p",null,"The following points should be kept in mind when updating a state value:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Avoid calling state update methods in the ",(0,i.mdx)("inlineCode",{parentName:"li"},"@OnCreateLayout")," method of a component. Every state update method triggers a new layout calculation, which re-invokes the render method of the component that triggered the state update. This can easily lead to an infinite loop. Consider whether a ",(0,i.mdx)("a",{parentName:"li",href:"#lazy-state"},"lazy state")," update would be more appropriate for the specific use case, and only use state updates in a render method if absolutely certain that the state update is conditionally called and can only be triggered a limited number of times."),(0,i.mdx)("li",{parentName:"ul"},"In ",(0,i.mdx)("a",{parentName:"li",href:"/docs/codegen/mount-specs"},"MountSpecs"),", state updates are not allowed in ",(0,i.mdx)("inlineCode",{parentName:"li"},"bind")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"mount")," methods as they cause a runtime exception if used. If there is a need to update a state value in those methods, use a ",(0,i.mdx)("a",{parentName:"li",href:"#lazy-state"},"lazy state")," update.")),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"In the Java API, the way in which a component's state or states should be updated can be defined by declaring methods annotated with ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," in the specs. There can be as many ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," methods as needed, depending on what states are to be updated and what parameters the states depend on."),(0,i.mdx)("p",{parentName:"admonition"},"The following points should be considered when writing an ",(0,i.mdx)("inlineCode",{parentName:"p"},"@OnUpdateState")," method:"),(0,i.mdx)("ul",{parentName:"admonition"},(0,i.mdx)("li",{parentName:"ul"},"Parameters representing the state values must match the name of a parameter annotated with ",(0,i.mdx)("inlineCode",{parentName:"li"},"@State")," and used in other lifecycle methods, and their type must be a ",(0,i.mdx)("inlineCode",{parentName:"li"},"StateValue")," parameterized with the type of the matching ",(0,i.mdx)("inlineCode",{parentName:"li"},"@State"),"."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"@Prop"),"s are not allowed, but ",(0,i.mdx)("inlineCode",{parentName:"li"},"@Param")," parameters are. If the value of the state depends on props, they can be passed as",(0,i.mdx)("inlineCode",{parentName:"li"},"@Param")," params from the lifecycle methods that call the state update methods."),(0,i.mdx)("li",{parentName:"ul"},"For each @OnUpdateState method in the spec, the generated component will have two methods that delegate to the @OnUpdateState method under the hood:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"A static method with the same name - asynchronously applies the state updates."),(0,i.mdx)("li",{parentName:"ul"},"A static method with the same name and a ",(0,i.mdx)("em",{parentName:"li"},"Sync")," suffix - synchronously triggers the state updates."),(0,i.mdx)("li",{parentName:"ul"},"Both methods take a ",(0,i.mdx)("inlineCode",{parentName:"li"},"ComponentContext")," as first parameter, followed by all the parameters declared with ",(0,i.mdx)("inlineCode",{parentName:"li"},"@Param")," in the ",(0,i.mdx)("inlineCode",{parentName:"li"},"@OnUpdateState")," method.")))),(0,i.mdx)("h2",{parentName:"admonition",id:"lazy-state"},"Lazy State"),(0,i.mdx)("p",{parentName:"admonition"},"For situations where there is a need to update the value of a state but no need to immediately trigger a new layout calculation, ",(0,i.mdx)("strong",{parentName:"p"},"lazy state updates")," can be used. After a lazy state update, the new state value is visible in event handlers, but a new layout is not triggered."),(0,i.mdx)("p",{parentName:"admonition"},"Currently, the value is immediately visible to the event handler but ",(0,i.mdx)("strong",{parentName:"p"},"not")," visible to other lifecycle callbacks (such as ",(0,i.mdx)("inlineCode",{parentName:"p"},"onMount"),")."),(0,i.mdx)("p",{parentName:"admonition"},"Lazy state is useful for updating state values that don't need to be reflected in the UI. For example, say there is a requirement to log an analytics event only the first time a component becomes visible. If lazy state was used, a record can be made of whether a log was sent in a lazy state variable without causing the UI to reflow."),(0,i.mdx)("p",{parentName:"admonition"},"Lazy state can still be used for regular state updates."),(0,i.mdx)("pre",{parentName:"admonition"},(0,i.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java start=start_lazy_state end=end_lazy_state",file:"sample/src/main/java/com/facebook/samples/litho/java/identity/IdentityRootComponentSpec.java",start:"start_lazy_state",end:"end_lazy_state"},"@OnEvent(VisibleEvent.class)\nstatic void onClickEvent(ComponentContext c, @State(canUpdateLazily = true) boolean logOnce) {\n  if (!logOnce) {\n    // do some logging\n    IdentityRootComponent.lazyUpdateLogOnce(c, true);\n  }\n}\n"))))}h.isMDXComponent=!0}}]);