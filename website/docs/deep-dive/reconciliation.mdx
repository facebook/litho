---
id: reconciliation
title: Reconciliation
---

import {FbInternalOnly, OssOnly} from 'internaldocs-fb-helpers';

## Introduction

Reconciliation is an implementation detail in Litho’s layout calculation process. Instead of
recreating the entire layout tree for every update reconciliation enables Litho to clone the
unmodified subtrees and only recreate the subtree which has changed.

When using Litho, the component hierarchy is determined by what is returned by the
`OnCreateLayout` method. On the next state or prop update, the `OnCreateLayout` may return a different
tree of components. Litho uses reconciliation to figure out which components should be re-created
and which can be re-used (read cloned).

In essence, this means Litho will not call (most) lifecycle methods of components which were
unaffected by the update. Reconciliation doubles down on the requirement that component specs must
be immutable and should not rely on side effects to achieve any desired behaviour.

:::note
As of December 2020 reconciliation is only implemented for state updates.
:::

## Enabling Reconciliation

:::info
Reconciliation is enabled by default.
:::

<FbInternalOnly>

:::tip
It has been explicitly disabled throughout fbsource because reconciliation skips some lifecycle calls which some components may have (incorrectly) come to rely on. So, please remove the usages of the following deprecated APIs in your surface before proceeding.
:::

</FbInternalOnly>

<OssOnly>

:::tip
Please remove the usages of the following deprecated APIs in your surface before proceeding.
:::

</OssOnly>

```java
// Remove usages of
LithoView#create(Context, Component, boolean): LithoView
LithoView#create(ComponentContext, Component, boolean): LithoView
LithoView#setComponentWithoutReconciliation(Component): void
LithoView#setComponentAsyncWithoutReconciliation(Component): void

// Instead use
LithoView#create(Context, Component): LithoView
LithoView#create(ComponentContext, Component): LithoView
LithoView#setComponent(Component): void
LithoView#setComponentAsync(Component): void
```

<FbInternalOnly>

:::info
Please remove the usages of the prop `isReconciliationEnabled` from the following components in your surface before proceeding:
* `FBInfiniteHScroll`
:::info

</FbInternalOnly>

### ComponentTree

The `ComponentTree` builder exposes an API to enable or disable reconciliation.

```java
ComponentTree.create(context)
  .isReconciliationEnabled(true)
  .build();
```

<FbInternalOnly>

Example integrations:
* [Feed](https://fburl.com/diffusion/azpz7q8u)
* [Story Viewer](https://fburl.com/diffusion/xv0puz80)

</FbInternalOnly>

:::note
In this integration the config is not passed into any Sections within the component
hierarchy. It needs to be explicitly set in the Sections (see below). There are plans to enable
propagation over the Section boundary in future milestones.**
:::

### RecyclerCollectionComponent

The `RecyclerBinderConfiguration` and the `RecyclerBinder` builders both expose an API to enable or
disable reconciliation.

```java
RecyclerBinderConfiguration.create()
  .isReconciliationEnabled(false)
  .build();
```


```java
new RecyclerBinder.Builder()
  .isReconciliationEnabled(true)
  .build(context);
```
<FbInternalOnly>

Example integrations:
* [Notifications Tab](https://fburl.com/diffusion/l10jx2ys)
* [Watch Tab](https://fburl.com/diffusion/ld30lvlm)
* [Profile Tab](https://fburl.com/diffusion/tp4j1arg)

</FbInternalOnly>

### Sections

The `ComponentRenderInfo` builder exposes an API to enable or disable reconciliation for individual
Sections in a `GroupSectionSpec`.

```java
ComponentRenderInfo.create()
  .component(component)
  .customAttribute(ComponentRenderInfo.RECONCILIATION_ENABLED, false)
  .build();
```

<FbInternalOnly>

Example integrations:
* [PaginatedStoriesHScrollSectionSpec](https://fburl.com/diffusion/2h1npnoj)
* [StoriesHScrollSectionSpec](https://fburl.com/diffusion/jhsnym17)

</FbInternalOnly>

## Tradeoffs

It is important to remember that the reconciliation algorithm is an implementation detail. Litho
could re-create the whole hierarchy on every action; the end result would be the same. Just to be
clear, re-creation in this context means calling `OnCreateLayout` for the modified component, it
doesn’t mean Litho will unmount and remount them. Litho will only mount and unmount items will
which have changed.

In order to reconcile changes, Litho keeps the previous component hierarchy in memory. This
increases memory usage and can potentially increase OOMs.
