---
id: layout-specs
title: Layout Specs
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="java"
  values={[
    {label: 'Java', value: 'java'},
    {label: 'Kotlin', value: 'kotlin'},
  ]}>
  <TabItem value="java">

A *layout spec* is the logical equivalent of a composite view on Android. It simply groups existing components together in an immutable layout tree.

Implementing a layout spec is very simple: you only need to write one method annotated with `@OnCreateLayout` which returns an immutable tree of [Component](/javadoc/com/facebook/litho/Component.html) objects.

Let's start with a simple example:

```java
@LayoutSpec
public class MyComponentSpec {

  @OnCreateLayout
  static Component onCreateLayout(
      ComponentContext c,
      @Prop int color,
      @Prop String title) {
      return Row.create(c)
          .alignItems(CENTER)
          .child(
              SolidColor.create(c)
                  .colorRes(color)
                  .widthDip(40)
                  .heightDip(40))
          .child(
              Text.create(c)
                  .text(title)
                  .textSizeRes(R.dimen.my_text_size)
                  .flexGrow(1f))
          .build();
  }
}
```

As you can see, layout spec classes use the `@LayoutSpec` annotation.

The method annotated with `@OnCreateLayout` must have [ComponentContext](/javadoc/com/facebook/litho/ComponentContext.html) as its first argument followed by a list of arguments annotated with `@Prop`. The annotation processor will validate this and other invariants in the API at build time.

In the example above, the layout tree has a root *Container* with two children stacked horizontally (`Row.create`) and vertically centered (`Align.CENTER`).

The first child is a [SolidColor](/javadoc/com/facebook/litho/widget/SolidColor.html) component that takes a `colorRes` prop and has a 40dp width and height.

```java
SolidColor.create(c)
    .colorRes(color)
    .width(40)
    .height(40)
```

The second child is a [Text](/javadoc/com/facebook/litho/widget/Text) component that takes a prop named `text` and fills the remaining horizontal space available in `MyComponent` by using `grow(1f)` (equivalent to Android's `layoutWeight` from `LinearLayout`). The text size is defined in `my_text_size` dimension resource.

```java
Text.create(c)
    .text(title)
    .textSizeRes(R.dimen.my_text_size)
    .grow(1f)
```

![Layout Spec lifecycle flowchart](/images/flow-chart-v0.23.1-layout-spec.svg)

You can check the full [Yoga](https://yogalayout.com/docs/) documentation to see all the layout features that the framework exposes.

  </TabItem>
  <TabItem value="kotlin">

A *layout spec* is the logical equivalent of a composite view on Android. It simply groups existing components together in an immutable layout tree.

Implementing a layout spec is very simple: you only need to write one method annotated with `@OnCreateLayout` which returns an immutable tree of [Component](/javadoc/com/facebook/litho/Component.html) objects.

Let's start with a simple example:

```kotlin
@LayoutSpec
object MyComponentSpec {

  @OnCreateLayout
  fun onCreateLayout(
      c: ComponentContext,
      @Prop image: String,
      @Prop(optional = true) imageAspectRatio: Float): Component = 
      Row.create(c)
          .alignItems(CENTER)
          .child(
              SolidColor.create(c)
                  .colorRes(color)
                  .widthDip(40)
                  .heightDip(40))
          .child(
              Text.create(c)
                  .text(title)
                  .textSizeRes(R.dimen.my_text_size)
                  .flexGrow(1f))
          .build()
}
```

As you can see, layout spec classes use the `@LayoutSpec` annotation.

The method annotated with `@OnCreateLayout` must have [ComponentContext](/javadoc/com/facebook/litho/ComponentContext.html) as its first argument followed by a list of arguments annotated with `@Prop`. The annotation processor will validate this and other invariants in the API at build time.

In the example above, the layout tree has a root *Container* with two children stacked horizontally (`Row.create`) and vertically centered (`Align.CENTER`).

The first child is a [SolidColor](/javadoc/com/facebook/litho/widget/SolidColor.html) component that takes a `colorRes` prop and has a 40dp width and height.

```kotlin
SolidColor.create(c)
    .colorRes(color)
    .width(40)
    .height(40)
```

The second child is a [Text](/javadoc/com/facebook/litho/widget/Text.html) component that takes a prop named `text` and fills the remaining horizontal space available in `MyComponent` by using `grow(1f)` (equivalent to Android's `layoutWeight` from `LinearLayout`). The text size is defined in `my_text_size` dimension resource.

```kotlin
Text.create(c)
    .text(title)
    .textSizeRes(R.dimen.my_text_size)
    .grow(1f)
```

![Layout Spec lifecycle flowchart](/images/flow-chart-v0.23.1-layout-spec.svg)

You can check the full [Yoga](https://yogalayout.com/docs/) documentation to see all the layout features that the framework exposes.

  </TabItem>
</Tabs>
